<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="offline-ready" content="true">
    <title>O√≥cito 3D Interativo - Modelo Detalhado</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    <link rel="mask-icon" href="favicon.svg" color="#f59e0b">
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1e3c72, #2a5298);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 14px;
            max-width: 300px;
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            z-index: 100;
        }
        
        .control-button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .control-button:hover {
            background: #45a049;
        }
        
        #zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            min-width: 250px;
            z-index: 100;
        }
        
        .zoom-slider-container {
            margin: 10px 0;
        }
        
        .zoom-slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #333;
            outline: none;
            -webkit-appearance: none;
        }
        
        .zoom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .zoom-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        
        .zoom-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .zoom-btn {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s;
        }
        
        .zoom-btn:hover {
            background: #45a049;
        }
        
        .zoom-btn.preset {
            background: #2196F3;
        }
        
        .zoom-btn.preset:hover {
            background: #1976D2;
        }
        
        .zoom-level {
            font-weight: bold;
            color: #4CAF50;
            text-align: center;
            margin: 5px 0;
            font-size: 14px;
        }
        
        #ai-assistant {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 60, 0.9));
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-family: Arial, sans-serif;
            max-width: 350px;
            min-height: 200px;
            z-index: 100;
            border: 2px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.3);
            transition: all 0.3s ease;
        }
        
        #ai-assistant.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(-50%) translateX(-100%);
        }
        
        .ai-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
            border-bottom: 1px solid #4CAF50;
            padding-bottom: 10px;
        }
        
        .ai-icon {
            font-size: 24px;
            margin-right: 10px;
            color: #4CAF50;
        }
        
        .ai-title {
            font-size: 18px;
            font-weight: bold;
            color: #4CAF50;
        }
        
        .ai-content {
            line-height: 1.6;
            font-size: 14px;
        }
        
        .ai-structure-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            margin-bottom: 10px;
        }
        
        .ai-description {
            margin-bottom: 15px;
        }
        
        .ai-function {
            background: rgba(76, 175, 80, 0.1);
            padding: 10px;
            border-radius: 8px;
            border-left: 3px solid #4CAF50;
            margin-bottom: 10px;
        }
        
        .ai-function-title {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .ai-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #4CAF50;
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }
        
        .ai-close-btn:hover {
            color: #FFD700;
        }
        
        .ai-toggle-btn {
            position: absolute;
            top: 50%;
            left: 20px;
            transform: translateY(-50%);
            background: linear-gradient(135deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            z-index: 101;
            box-shadow: 0 4px 15px rgba(76, 175, 80, 0.4);
            transition: all 0.3s ease;
        }
        
        .ai-toggle-btn:hover {
            transform: translateY(-50%) scale(1.1);
            box-shadow: 0 6px 20px rgba(76, 175, 80, 0.6);
        }
        
        .ai-hint {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #4CAF50;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            z-index: 100;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .ai-config-btn {
            background: none;
            border: none;
            color: #4CAF50;
            font-size: 14px;
            cursor: pointer;
            padding: 2px 5px;
            border-radius: 3px;
            transition: background-color 0.3s;
        }
        
        .ai-config-btn:hover {
            background-color: rgba(76, 175, 80, 0.1);
        }
        
        .ai-config-panel {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        .ai-config-header {
            background: #4CAF50;
            color: white;
            padding: 8px 12px;
            font-weight: bold;
            font-size: 12px;
        }
        
        .ai-config-content {
            padding: 12px;
        }
        
        .ai-config-content label {
            display: block;
            margin-bottom: 5px;
            font-size: 11px;
            font-weight: bold;
            color: #333;
        }
        
        .ai-config-content input {
            width: 100%;
            padding: 6px 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 10px;
            box-sizing: border-box;
        }
        
        .ai-config-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .ai-config-buttons button {
            flex: 1;
            padding: 6px 8px;
            border: none;
            border-radius: 4px;
            font-size: 10px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .ai-save-btn {
            background: #4CAF50;
            color: white;
        }
        
        .ai-save-btn:hover {
            background: #45a049;
        }
        
        .ai-test-btn {
            background: #2196F3;
            color: white;
        }
        
        .ai-test-btn:hover {
            background: #1976D2;
        }
        
        .ai-clear-btn {
            background: #f44336;
            color: white;
        }
        
        .ai-clear-btn:hover {
            background: #d32f2f;
        }
        
        .ai-config-status {
            padding: 6px 8px;
            border-radius: 4px;
            font-size: 10px;
            margin-bottom: 8px;
            text-align: center;
        }
        
        .ai-config-status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .ai-config-status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .ai-config-status.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        .ai-config-info {
            font-size: 9px;
            color: #666;
            line-height: 1.3;
        }
        
        .ai-powered-badge {
            margin-top: 10px;
            padding: 5px 8px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            text-align: center;
            font-size: 10px;
        }
        
        .loading-spinner {
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #legend {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            font-size: 12px;
            max-width: 250px;
            z-index: 100;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            margin-right: 8px;
            border-radius: 3px;
        }
        
        .label {
            position: absolute;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 11px;
            pointer-events: none;
            z-index: 50;
            border: 1px solid #fff;
        }

        /* Estilos para pain√©is retr√°teis */
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
        }

        .panel-toggle-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            color: white;
            width: 20px;
            height: 20px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s;
        }

        .panel-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .panel-content {
            transition: all 0.3s ease;
            overflow: hidden;
        }

        .panel-content.collapsed {
            max-height: 0;
            opacity: 0;
            margin: 0;
            padding: 0;
        }

        .panel-minimized {
            background: rgba(0, 0, 0, 0.9) !important;
            padding: 8px !important;
        }

        .panel-minimized .panel-content {
            display: none;
        }

        /* Estilos espec√≠ficos para cada painel */
        #legend.panel-minimized {
            max-width: 120px;
        }

        #transport-controls.panel-minimized {
            min-width: auto;
            width: 180px;
        }

        #ai-assistant.ai-minimized {
            height: auto !important;
            min-height: auto !important;
        }

        #ai-assistant.ai-minimized .ai-content,
        #ai-assistant.ai-minimized .ai-config-panel {
            display: none !important;
        }
    </style>
<link rel="stylesheet" href="./libs/fonts.css">
</head>
<body>
    <!-- Indicador de modo offline -->
    <div id="offline-indicator" style="
        position: fixed;
        top: 10px;
        right: 10px;
        background: linear-gradient(45deg, #ff6b35, #f7931e);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.8rem;
        font-weight: 600;
        z-index: 10000;
        display: none;
        align-items: center;
        gap: 6px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
    ">
        <span style="
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        "></span>
        <span>Modo Offline</span>
    </div>
    
    <style>
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
    
    <script>
        // Mostrar indicador offline
        function updateOfflineIndicator() {
            const indicator = document.getElementById('offline-indicator');
            if (!navigator.onLine) {
                indicator.style.display = 'flex';
            } else {
                indicator.style.display = 'none';
            }
        }
        
        window.addEventListener('online', updateOfflineIndicator);
        window.addEventListener('offline', updateOfflineIndicator);
        document.addEventListener('DOMContentLoaded', updateOfflineIndicator);
    </script>
    <div id="container">
        <div id="info">
            <h3>üî¨ O√≥cito 3D Interativo</h3>
            <p><strong>Controles:</strong></p>
            <p>‚Ä¢ Arrastar: Rotacionar</p>
            <p>‚Ä¢ Scroll: Zoom</p>
            <p>‚Ä¢ Clique direito: Pan</p>
            <p>‚Ä¢ Clique em estruturas para destacar</p>
        </div>
        
        <div id="controls">
            <h4>Controles</h4>
            <button class="control-button" onclick="resetView()">Reset View</button>
            <button class="control-button" onclick="toggleLabels()">Labels</button>
            <button class="control-button" onclick="toggleAnimation()">Anima√ß√£o</button>
            <button class="control-button" onclick="toggleWireframe()">Wireframe</button>
            <button class="control-button" onclick="toggleCrossSection()">Corte Transversal</button>
            <button class="control-button" onclick="toggleQuarterSection()">Corte em Quarto</button>
            <button class="control-button" onclick="toggleThreeQuarterSection()">Corte em 3/4</button>
            
            <h5>Estruturas Avan√ßadas</h5>
            <button class="control-button" onclick="toggleZincSparks()">Zinc Sparks</button>
            <button class="control-button" onclick="toggleZincTransporters()">Transportadores Zn</button>
            <button class="control-button" onclick="toggleSpermCell()">Espermatozoide</button>
            <button class="control-button" onclick="toggleCorticalReaction()">Gr√¢nulos Corticais</button>
            
            <h5>Rea√ß√µes Biol√≥gicas</h5>
            <button class="control-button" onclick="triggerZincSparks()">Ativar Zinc Sparks</button>
            <button class="control-button" onclick="triggerCorticalReaction()">Rea√ß√£o Cortical</button>
            <button class="control-button" onclick="triggerAcrosomeReaction()">Rea√ß√£o Across√¥mica</button>
        </div>
        
        <div id="zoom-controls">
            <h4>üîç Controles de Zoom</h4>
            <div class="zoom-level">Zoom: <span id="zoom-value">1.0x</span></div>
            
            <div class="zoom-slider-container">
                <input type="range" id="zoom-slider" class="zoom-slider" 
                       min="0.5" max="10" step="0.1" value="1.0">
            </div>
            
            <div class="zoom-buttons">
                <button class="zoom-btn" onclick="zoomIn()">+</button>
                <button class="zoom-btn" onclick="zoomOut()">-</button>
                <button class="zoom-btn preset" onclick="setZoomPreset('overview')">Vis√£o Geral</button>
                <button class="zoom-btn preset" onclick="setZoomPreset('detail')">Detalhes</button>
                <button class="zoom-btn preset" onclick="setZoomPreset('ultra')">Ultra</button>
                <button class="zoom-btn preset" onclick="setZoomPreset('molecular')">Molecular</button>
                <button class="zoom-btn preset" onclick="setZoomPreset('chemical')">Qu√≠mico</button>
            </div>
        </div>
        
        <!-- Transport Controls Panel -->
        <div id="transport-controls" style="position: absolute; top: 10px; left: 300px; background: rgba(0,0,0,0.8); padding: 15px; border-radius: 10px; color: white; font-family: Arial, sans-serif; font-size: 12px; min-width: 200px; z-index: 1000;">
            <div class="panel-header" onclick="togglePanel('transport-controls')">
                <h4 style="margin: 0; color: #4CAF50;">Controles de Transporte</h4>
                <button class="panel-toggle-btn" id="transport-controls-toggle">‚àí</button>
            </div>
            <div class="panel-content" id="transport-controls-content">
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-transport-proteins" onchange="toggleTransportProteins()" style="margin-right: 8px;">
                    <span>Prote√≠nas de Transporte</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-na-k-pumps" onchange="toggleNaKPumps()" style="margin-right: 8px;">
                    <span>Bombas Na+/K+</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-ion-channels" onchange="toggleIonChannels()" style="margin-right: 8px;">
                    <span>Canais I√¥nicos</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-glucose-transporters" onchange="toggleGlucoseTransporters()" style="margin-right: 8px;">
                    <span>Transportadores de Glicose</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-chemical-reactions" onchange="toggleChemicalReactionsControl()" style="margin-right: 8px;">
                    <span>Rea√ß√µes Qu√≠micas</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-molecular-transport" onchange="toggleMolecularTransportControl()" style="margin-right: 8px;">
                    <span>Transporte Molecular</span>
                </label>
            </div>
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; cursor: pointer;">
                    <input type="checkbox" id="toggle-zinc-transporters" onchange="toggleZincTransporters()" style="margin-right: 8px;">
                    <span>Transportadores de Zinco</span>
                </label>
            </div>
            </div>
        </div>
        
        <!-- AI Assistant Panel -->
        <button id="ai-toggle-btn" class="ai-toggle-btn" onclick="toggleAI()">ü§ñ</button>
        
        <div id="ai-assistant" class="hidden">
            <button class="ai-close-btn" onclick="hideAI()">√ó</button>
            <div class="ai-header">
                <span class="ai-icon">üß†</span>
                <span class="ai-title">Assistente IA</span>
                <div style="display: flex; gap: 5px;">
                    <button class="panel-toggle-btn" onclick="toggleAIPanel()" title="Minimizar/Maximizar">‚àí</button>
                    <button class="ai-config-btn" onclick="toggleAIConfig()" title="Configurar API OpenAI">‚öôÔ∏è</button>
                </div>
            </div>
            
            <!-- OpenAI API Configuration Panel -->
            <div id="ai-config-panel" class="ai-config-panel hidden">
                <div class="ai-config-header">
                    <span>üîë Configura√ß√£o OpenAI</span>
                </div>
                <div class="ai-config-content">
                    <label for="openai-key-input">Chave da API OpenAI:</label>
                    <input type="password" id="openai-key-input" placeholder="sk-..." />
                    <div class="ai-config-buttons">
                        <button onclick="saveOpenAIKey()" class="ai-save-btn">Salvar</button>
                        <button onclick="testOpenAIConnection()" class="ai-test-btn">Testar</button>
                        <button onclick="clearOpenAIKey()" class="ai-clear-btn">Limpar</button>
                    </div>
                    <div id="ai-config-status" class="ai-config-status"></div>
                    <div class="ai-config-info">
                        <small>
                            ‚ÑπÔ∏è A chave √© armazenada localmente no seu navegador.<br>
                            Com a API configurada, a IA pode identificar estruturas com precis√£o cient√≠fica.
                        </small>
                    </div>
                </div>
            </div>
            
            <div class="ai-content" id="ai-content">
                <div class="ai-structure-name">Bem-vindo ao Modelo 3D Avan√ßado!</div>
                <div class="ai-description">
                    Explore o o√≥cito em detalhes moleculares! Este modelo inclui prote√≠nas de transporte, bombas Na+/K+, canais i√¥nicos e visualiza√ß√£o de rea√ß√µes qu√≠micas.
                </div>
                <div class="ai-function">
                    <div class="ai-function-title">üî¨ Recursos Avan√ßados:</div>
                    <ul style="margin: 5px 0; padding-left: 15px; font-size: 11px;">
                        <li><strong>Zoom Molecular:</strong> Use os presets "Molecular" e "Qu√≠mico" para ver rea√ß√µes em tempo real</li>
                        <li><strong>Prote√≠nas de Transporte:</strong> Visualize GLUT, transportadores de amino√°cidos e canais i√¥nicos</li>
                        <li><strong>Bombas Na+/K+:</strong> Observe o funcionamento das bombas de s√≥dio-pot√°ssio</li>
                        <li><strong>Rea√ß√µes Qu√≠micas:</strong> Veja ATP, √≠ons Na+/K+ e metabolismo de glicose</li>
                        <li><strong>Transporte Molecular:</strong> Acompanhe o movimento de prote√≠nas, lip√≠dios e metab√≥litos</li>
                    </ul>
                </div>
                <div class="ai-function">
                    <div class="ai-function-title">üí° Dica:</div>
                    Use o painel "Controles de Transporte" para ativar/desativar diferentes sistemas moleculares.
                </div>
            </div>
        </div>
        
        <div id="ai-hint" class="ai-hint">
            Clique nas estruturas para aprender mais! üî¨
        </div>
        
        <div id="legend">
            <div class="panel-header" onclick="togglePanel('legend')">
                <h4 style="margin: 0;">Legenda</h4>
                <button class="panel-toggle-btn" id="legend-toggle">‚àí</button>
            </div>
            <div class="panel-content" id="legend-content">
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Zona Pel√∫cida</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF69B4;"></div>
                <span>Membrana Plasm√°tica</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9370DB;"></div>
                <span>N√∫cleo</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #32CD32;"></div>
                <span>Mitoc√¥ndrias</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF4500;"></div>
                <span>Gr√¢nulos Corticais</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00CED1;"></div>
                <span>Ret√≠culo Endoplasm√°tico</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF0000;"></div>
                <span>Bombas Na+/K+</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00FF00;"></div>
                <span>Canais I√¥nicos</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #0000FF;"></div>
                <span>Transportadores GLUT</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFFF00;"></div>
                <span>Mol√©culas ATP/Glicose</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF6600;"></div>
                <span>√çons Na+</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #9966FF;"></div>
                <span>√çons K+</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFD700;"></div>
                <span>Zinc Sparks</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8A2BE2;"></div>
                <span>Transportadores de Zinco</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF1493;"></div>
                <span>Espermatozoide</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00FFFF;"></div>
                <span>Rea√ß√£o Cortical</span>
            </div>
            </div>
        </div>
    </div>

    <script src="./libs/three.min.js"></script>
    <script src="./libs/OrbitControls.js"></script>
    
    <script>
        // Vari√°veis globais
        let scene, camera, renderer, controls;
        let oocyteGroup, nucleusGroup, organellesGroup;
        let animationId;
        let isAnimating = true;
        let showLabels = true;
        let showWireframe = false;
        let labels = [];
        
        // Novas vari√°veis para funcionalidades avan√ßadas
        let zincSparksGroup, spermGroup, corticalReactionGroup;
        
        // Verifica√ß√£o para evitar redeclara√ß√µes
        if (typeof window.zincSparksGroup !== 'undefined') {
            zincSparksGroup = window.zincSparksGroup;
        }
        if (typeof window.spermGroup !== 'undefined') {
            spermGroup = window.spermGroup;
        }
        if (typeof window.corticalReactionGroup !== 'undefined') {
            corticalReactionGroup = window.corticalReactionGroup;
        }
        let crossSectionEnabled = false;
        let crossSectionPlane;
        let quarterSectionEnabled = false;
        let quarterSectionPlanes = [];
        let threeQuarterSectionEnabled = false;
        let threeQuarterSectionPlanes = [];
        let zincSparksActive = false;
        let corticalReactionActive = false;
        let acrosomeReactionActive = false;
        let zincTransportersGroup;
        
        // Inicializa√ß√£o
        init();
        animate();
        
        function init() {
            // Cena
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            
            // C√¢mera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.localClippingEnabled = true; // Habilitar clipping local
            document.getElementById('container').appendChild(renderer.domElement);
            
            // Controles
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.08;
            controls.minDistance = 2;
            controls.maxDistance = 50;
            controls.zoomSpeed = 1.5;
            controls.rotateSpeed = 0.8;
            controls.panSpeed = 1.2;
            
            // Ilumina√ß√£o
            setupLighting();
            
            // Criar estruturas do o√≥cito
            createOocyte();
            
            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            
            // Initialize AI Assistant
            initAIAssistant();
            
            // Initialize AI Metabolism System after scene is fully configured
            setTimeout(() => {
                // Verificar se todas as depend√™ncias est√£o carregadas
                if (typeof AIMetabolismEngine !== 'undefined' && 
                    typeof MetabolismSimulator !== 'undefined' && 
                    typeof ProteinTransportSimulator !== 'undefined' &&
                    typeof MetabolismControlInterface !== 'undefined' &&
                    typeof DynamicVisualization !== 'undefined') {
                    initializeAIMetabolismSystem();
                } else {
                    console.warn('‚ö†Ô∏è Aguardando carregamento das depend√™ncias do sistema de IA...');
                    // Tentar novamente ap√≥s mais tempo
                    setTimeout(() => {
                        if (typeof ProteinTransportSimulator !== 'undefined') {
                            initializeAIMetabolismSystem();
                        } else {
                            console.error('‚ùå Falha ao carregar ProteinTransportSimulator');
                        }
                    }, 2000);
                }
            }, 500);
        }
        
        function setupLighting() {
            // Luz ambiente mais suave para criar atmosfera
            const ambientLight = new THREE.AmbientLight(0x2a2a3a, 0.3);
            scene.add(ambientLight);
            
            // Luz direcional principal mais intensa
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(15, 15, 10);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 4096;
            directionalLight.shadow.mapSize.height = 4096;
            directionalLight.shadow.camera.near = 0.1;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -20;
            directionalLight.shadow.camera.right = 20;
            directionalLight.shadow.camera.top = 20;
            directionalLight.shadow.camera.bottom = -20;
            scene.add(directionalLight);
            
            // Luz de preenchimento suave
            const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.4);
            fillLight.position.set(-10, -10, 5);
            scene.add(fillLight);
            
            // Luzes pontuais para destacar organelas espec√≠ficas
            const mitochondriaLight = new THREE.PointLight(0xFF7F50, 0.8, 30);
            mitochondriaLight.position.set(0, 0, 0);
            scene.add(mitochondriaLight);
            
            // Luz adicional para real√ßar as cristae azuis/roxas
            const cristaeLight = new THREE.PointLight(0x6A5ACD, 0.5, 20);
            cristaeLight.position.set(5, 5, 5);
            scene.add(cristaeLight);
            
            const nucleusLight = new THREE.PointLight(0x4169e1, 0.4, 20);
            nucleusLight.position.set(0, 0, 0);
            scene.add(nucleusLight);
            
            // Luz rim para contorno
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.5);
            rimLight.position.set(-15, 5, -10);
            scene.add(rimLight);
            
            // Luz de destaque superior
            const topLight = new THREE.PointLight(0xffffff, 0.8, 30);
            topLight.position.set(0, 20, 0);
            scene.add(topLight);
        }
        
        function createOocyte() {
            oocyteGroup = new THREE.Group();
            nucleusGroup = new THREE.Group();
            organellesGroup = new THREE.Group();
            follicleGroup = new THREE.Group();
            
            // 1. Zona Pel√∫cida (camada externa transparente)
            createZonaPellucida();
            
            // 2. Corona Radiata (c√©lulas foliculares externas)
            createCoronaRadiata();
            
            // 2.1. Follicle cells
            createFollicleCells();
            
            // 3. Membrana plasm√°tica
            createPlasmaMembrane();
            
            // 4. Citoplasma
            createCytoplasm();
            
            // 5. N√∫cleo (meiotic stage)
            createNucleus();
            
            // 5.1. Centrosomes and meiotic spindle
            createCentrosomesAndSpindle();
            
            // 6. Organelas
            createOrganelles();
            
            // 6.1. Cytoskeleton
             const cytoskeleton = createCytoskeleton();
             organellesGroup.add(cytoskeleton);
             
             // 6.2. Calcium release
              const calciumRelease = createCalciumRelease();
              organellesGroup.add(calciumRelease);
              
              // 6.3. Zinc release
              const zincRelease = createZincRelease();
              organellesGroup.add(zincRelease);
              
              // 6.4. CD9 proteins on membrane
              const cd9Proteins = createCD9Proteins();
              organellesGroup.add(cd9Proteins);
              
              // 6.5. ZP3 proteins in zona pellucida
              const zp3Proteins = createZP3Proteins();
              organellesGroup.add(zp3Proteins);
              
              // 6.6. Zinc transporters (ZIP6/ZIP10)
              const zincTransporters = createZincTransporters();
              organellesGroup.add(zincTransporters);
              
              // 6.7. PLCZ proteins for calcium signaling
              const plczProteins = createPLCZProteins();
              organellesGroup.add(plczProteins);
              
              // 7. Gr√¢nulos corticais
            createCorticalGranules();
            
            // 8. Receptores e estruturas especiais
            createSpecialStructures();
            
            // 9. Novas estruturas avan√ßadas
            createZincSparks();
            createZincTransportersAdvanced();
            createSpermCell();
            createCorticalReactionSystem();
            createCrossSectionPlane();
            createQuarterSectionPlanes();
            createThreeQuarterSectionPlanes();
            
            scene.add(oocyteGroup);
            scene.add(nucleusGroup);
            scene.add(organellesGroup);
            scene.add(follicleGroup);
            
            // Criar labels
            createLabels();
        }
        
        function createZonaPellucida() {
            // Create perivitelline space (between plasma membrane and zona pellucida) - com corte em 3/4
            const perivitellineGeometry = new THREE.SphereGeometry(6.0, 64, 64, 0, Math.PI * 1.5);
            const perivitellineMaterial = new THREE.MeshPhongMaterial({
                color: 0xE6F3FF,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide
            });
            const perivitellineSpace = new THREE.Mesh(perivitellineGeometry, perivitellineMaterial);
            perivitellineSpace.name = 'perivitellineSpace';
            oocyteGroup.add(perivitellineSpace);
            
            // Create zona pellucida (outer glycoprotein layer) - com corte em 3/4 - estilo mais fibroso
            const zonaGeometry = new THREE.SphereGeometry(6.8, 64, 64, 0, Math.PI * 1.5);
            const zonaMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD700,  // Dourado mais vibrante
                transparent: true,
                opacity: 0.6,     // Mais opaco para melhor visibilidade
                side: THREE.DoubleSide,
                shininess: 100,   // Mais brilhante
                specular: 0xFFFFFF
            });
            const zonaPellucida = new THREE.Mesh(zonaGeometry, zonaMaterial);
            zonaPellucida.name = 'zonaPellucida';
            oocyteGroup.add(zonaPellucida);
            
            // Add zona pellucida glycoprotein fibers
            for (let i = 0; i < 40; i++) {
                const fiberGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.8, 6);
                const fiberMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFE55C,
                    transparent: true,
                    opacity: 0.6
                });
                const fiber = new THREE.Mesh(fiberGeometry, fiberMaterial);
                
                // Position fibers radially in zona pellucida
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                const radius = 6.4;
                
                fiber.position.set(
                    radius * Math.sin(theta) * Math.cos(phi),
                    radius * Math.sin(theta) * Math.sin(phi),
                    radius * Math.cos(theta)
                );
                
                // Orient fiber radially
                fiber.lookAt(new THREE.Vector3(0, 0, 0));
                fiber.rotateX(Math.PI / 2);
                
                oocyteGroup.add(fiber);
            }
        }
        
        function createCoronaRadiata() {
            // C√©lulas da corona radiata como pequenas esferas ao redor
            for (let i = 0; i < 200; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xFFA500,
                    transparent: true,
                    opacity: 0.7
                });
                const cell = new THREE.Mesh(geometry, material);
                
                // Posicionar em uma esfera ao redor da zona pel√∫cida
                const radius = 7.2 + Math.random() * 1;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                cell.position.x = radius * Math.sin(phi) * Math.cos(theta);
                cell.position.y = radius * Math.sin(phi) * Math.sin(theta);
                cell.position.z = radius * Math.cos(phi);
                
                oocyteGroup.add(cell);
            }
        }
        
        function createFollicleCells() {
            // Enhanced follicle cells with realistic structure
            for (let i = 0; i < 180; i++) {
                const follicleCell = new THREE.Group();
                
                // Cell body (cytoplasm)
                const cellGeometry = new THREE.SphereGeometry(0.35, 12, 12);
                const cellMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFB6C1,
                    transparent: true,
                    opacity: 0.8,
                    shininess: 30
                });
                const cellBody = new THREE.Mesh(cellGeometry, cellMaterial);
                follicleCell.add(cellBody);
                
                // Cell nucleus
                const nucleusGeometry = new THREE.SphereGeometry(0.15, 10, 10);
                const nucleusMaterial = new THREE.MeshPhongMaterial({
                    color: 0x4B0082,
                    transparent: true,
                    opacity: 0.9
                });
                const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                
                // Offset nucleus slightly from center
                nucleus.position.x = (Math.random() - 0.5) * 0.2;
                nucleus.position.y = (Math.random() - 0.5) * 0.2;
                nucleus.position.z = (Math.random() - 0.5) * 0.2;
                follicleCell.add(nucleus);
                
                // Nucleolus
                const nucleolusGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const nucleolusMaterial = new THREE.MeshPhongMaterial({
                    color: 0x2F4F4F
                });
                const nucleolus = new THREE.Mesh(nucleolusGeometry, nucleolusMaterial);
                nucleolus.position.copy(nucleus.position);
                nucleolus.position.x += (Math.random() - 0.5) * 0.08;
                nucleolus.position.y += (Math.random() - 0.5) * 0.08;
                nucleolus.position.z += (Math.random() - 0.5) * 0.08;
                follicleCell.add(nucleolus);
                
                // Cell organelles (simplified)
                for (let j = 0; j < 8; j++) {
                    const organelleGeometry = new THREE.SphereGeometry(0.02, 6, 6);
                    const organelleMaterial = new THREE.MeshPhongMaterial({
                        color: Math.random() > 0.5 ? 0x32CD32 : 0x00CED1
                    });
                    const organelle = new THREE.Mesh(organelleGeometry, organelleMaterial);
                    
                    // Position organelles randomly in cytoplasm
                    const orgRadius = 0.15 + Math.random() * 0.15;
                    const orgTheta = Math.random() * Math.PI * 2;
                    const orgPhi = Math.random() * Math.PI;
                    
                    organelle.position.x = orgRadius * Math.sin(orgPhi) * Math.cos(orgTheta);
                    organelle.position.y = orgRadius * Math.sin(orgPhi) * Math.sin(orgTheta);
                    organelle.position.z = orgRadius * Math.cos(orgPhi);
                    
                    follicleCell.add(organelle);
                }
                
                // Position follicle cells in direct contact with zona pellucida
                const radius = 6.1 + Math.random() * 0.3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                follicleCell.position.x = radius * Math.sin(phi) * Math.cos(theta);
                follicleCell.position.y = radius * Math.sin(phi) * Math.sin(theta);
                follicleCell.position.z = radius * Math.cos(phi);
                
                // Slight random rotation for natural appearance
                follicleCell.rotation.x = Math.random() * 0.5;
                follicleCell.rotation.y = Math.random() * 0.5;
                follicleCell.rotation.z = Math.random() * 0.5;
                
                follicleGroup.add(follicleCell);
            }
            
            // Add some cumulus cells (closer to zona pellucida)
            for (let i = 0; i < 60; i++) {
                const cumulusCell = new THREE.Group();
                
                // Smaller cumulus cell body
                const cellGeometry = new THREE.SphereGeometry(0.25, 10, 10);
                const cellMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFC0CB,
                    transparent: true,
                    opacity: 0.85
                });
                const cellBody = new THREE.Mesh(cellGeometry, cellMaterial);
                cumulusCell.add(cellBody);
                
                // Cell nucleus
                const nucleusGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const nucleusMaterial = new THREE.MeshPhongMaterial({
                    color: 0x483D8B,
                    transparent: true,
                    opacity: 0.9
                });
                const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
                cumulusCell.add(nucleus);
                
                // Position cumulus cells in direct contact with zona pellucida
                const radius = 6.05 + Math.random() * 0.1;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                cumulusCell.position.x = radius * Math.sin(phi) * Math.cos(theta);
                cumulusCell.position.y = radius * Math.sin(phi) * Math.sin(theta);
                cumulusCell.position.z = radius * Math.cos(phi);
                
                follicleGroup.add(cumulusCell);
            }
        }
        
        function createPlasmaMembrane() {
            const membraneGroup = new THREE.Group();
            
            // Outer leaflet of phospholipid bilayer - com corte em 3/4 - cores mais vibrantes
            const outerGeometry = new THREE.SphereGeometry(6.02, 64, 32, 0, Math.PI * 1.5); // Corte em 3/4
            const outerMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF1493,  // Rosa profundo vibrante
                transparent: true,
                opacity: 0.7,     // Mais vis√≠vel
                side: THREE.FrontSide,
                shininess: 90,
                specular: 0xFFFFFF
            });
            const outerLeaflet = new THREE.Mesh(outerGeometry, outerMaterial);
            
            // Inner leaflet of phospholipid bilayer - com corte em 3/4 - cores mais vibrantes
            const innerGeometry = new THREE.SphereGeometry(5.98, 64, 32, 0, Math.PI * 1.5); // Corte em 3/4
            const innerMaterial = new THREE.MeshPhongMaterial({
                color: 0x00CED1,  // Turquesa escuro vibrante
                transparent: true,
                opacity: 0.7,     // Mais vis√≠vel
                side: THREE.BackSide,
                shininess: 90,
                specular: 0xFFFFFF
            });
            const innerLeaflet = new THREE.Mesh(innerGeometry, innerMaterial);
            
            // Add phospholipid molecules
            for (let i = 0; i < 200; i++) {
                const phi = Math.acos(-1 + (2 * i) / 200);
                const theta = Math.sqrt(200 * Math.PI) * phi;
                
                // Phospholipid head (hydrophilic)
                const headGeometry = new THREE.SphereGeometry(0.05, 8, 6);
                const headMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD93D });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                
                // Position on membrane surface
                const x = 6 * Math.sin(phi) * Math.cos(theta);
                const y = 6 * Math.sin(phi) * Math.sin(theta);
                const z = 6 * Math.cos(phi);
                
                head.position.set(x, y, z);
                
                // Fatty acid tails (hydrophobic)
                const tailGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 6);
                const tailMaterial = new THREE.MeshPhongMaterial({ color: 0x95E1D3 });
                
                const tail1 = new THREE.Mesh(tailGeometry, tailMaterial);
                const tail2 = new THREE.Mesh(tailGeometry, tailMaterial);
                
                // Orient tails toward center
                const direction = new THREE.Vector3(x, y, z).normalize();
                tail1.position.copy(head.position).add(direction.clone().multiplyScalar(-0.08));
                tail2.position.copy(head.position).add(direction.clone().multiplyScalar(-0.08));
                tail2.position.add(new THREE.Vector3(0.02, 0, 0));
                
                tail1.lookAt(new THREE.Vector3(0, 0, 0));
                tail2.lookAt(new THREE.Vector3(0, 0, 0));
                
                membraneGroup.add(head, tail1, tail2);
            }
            
            // Add transport proteins and pumps
            createTransportProteins(membraneGroup);
            createSodiumPotassiumPumps(membraneGroup);
            createIonChannels(membraneGroup);
            createGlucoseTransporters(membraneGroup);
            createAminoAcidTransporters(membraneGroup);
            
            membraneGroup.add(outerLeaflet, innerLeaflet);
            membraneGroup.name = 'plasmaMembrane';
            oocyteGroup.add(membraneGroup);
        }
        
        function createTransportProteins(membraneGroup) {
            // Create various transport proteins embedded in the membrane
            const transportProteinsGroup = new THREE.Group();
            transportProteinsGroup.name = 'transportProteins';
            
            // Aquaporins (water channels)
            for (let i = 0; i < 15; i++) {
                const aquaporin = createAquaporin();
                positionOnMembrane(aquaporin, 6.0);
                transportProteinsGroup.add(aquaporin);
            }
            
            // Calcium channels
            for (let i = 0; i < 12; i++) {
                const calciumChannel = createCalciumChannel();
                positionOnMembrane(calciumChannel, 6.0);
                transportProteinsGroup.add(calciumChannel);
            }
            
            // Potassium channels
            for (let i = 0; i < 18; i++) {
                const potassiumChannel = createPotassiumChannel();
                positionOnMembrane(potassiumChannel, 6.0);
                transportProteinsGroup.add(potassiumChannel);
            }
            
            membraneGroup.add(transportProteinsGroup);
        }
        
        function createSodiumPotassiumPumps(membraneGroup) {
            const pumpsGroup = new THREE.Group();
            pumpsGroup.name = 'sodiumPotassiumPumps';
            
            // Create 25 Na+/K+ ATPase pumps
            for (let i = 0; i < 25; i++) {
                const pump = createNaKATPasePump();
                positionOnMembrane(pump, 6.0);
                pumpsGroup.add(pump);
            }
            
            membraneGroup.add(pumpsGroup);
        }
        
        function createNaKATPasePump() {
            const pumpGroup = new THREE.Group();
            pumpGroup.name = 'naKATPasePump';
            
            // Main protein structure (alpha subunit)
            const alphaGeometry = new THREE.CylinderGeometry(0.08, 0.12, 0.25, 8);
            const alphaMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF4444,
                transparent: true,
                opacity: 0.9
            });
            const alphaSubunit = new THREE.Mesh(alphaGeometry, alphaMaterial);
            
            // Beta subunit (smaller, glycosylated)
            const betaGeometry = new THREE.CylinderGeometry(0.05, 0.08, 0.2, 6);
            const betaMaterial = new THREE.MeshPhongMaterial({
                color: 0x4444FF,
                transparent: true,
                opacity: 0.8
            });
            const betaSubunit = new THREE.Mesh(betaGeometry, betaMaterial);
            betaSubunit.position.x = 0.1;
            
            // ATP binding site
            const atpSiteGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const atpSiteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFF00,
                emissive: 0x444400
            });
            const atpSite = new THREE.Mesh(atpSiteGeometry, atpSiteMaterial);
            atpSite.position.set(0, 0.15, 0);
            
            // Ion binding sites
            const naBindingSite = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 6, 6),
                new THREE.MeshPhongMaterial({ color: 0x00FF00, emissive: 0x004400 })
            );
            naBindingSite.position.set(-0.05, 0.05, 0);
            
            const kBindingSite = new THREE.Mesh(
                new THREE.SphereGeometry(0.02, 6, 6),
                new THREE.MeshPhongMaterial({ color: 0xFF00FF, emissive: 0x440044 })
            );
            kBindingSite.position.set(0.05, -0.05, 0);
            
            pumpGroup.add(alphaSubunit, betaSubunit, atpSite, naBindingSite, kBindingSite);
            
            // Add animation data
            pumpGroup.userData = {
                type: 'naKPump',
                animationPhase: Math.random() * Math.PI * 2,
                isActive: true
            };
            
            return pumpGroup;
        }
        
        function createAquaporin() {
            const aquaporinGroup = new THREE.Group();
            aquaporinGroup.name = 'aquaporin';
            
            // Main channel structure
            const channelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.2, 6);
            const channelMaterial = new THREE.MeshPhongMaterial({
                color: 0x00CCFF,
                transparent: true,
                opacity: 0.8
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            
            // Selectivity filter
            const filterGeometry = new THREE.TorusGeometry(0.025, 0.008, 6, 12);
            const filterMaterial = new THREE.MeshPhongMaterial({
                color: 0x0088CC
            });
            const filter = new THREE.Mesh(filterGeometry, filterMaterial);
            
            aquaporinGroup.add(channel, filter);
            aquaporinGroup.userData = { type: 'aquaporin' };
            
            return aquaporinGroup;
        }
        
        function createCalciumChannel() {
            const channelGroup = new THREE.Group();
            channelGroup.name = 'calciumChannel';
            
            // Channel pore
            const poreGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.22, 8);
            const poreMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFAA00,
                transparent: true,
                opacity: 0.85
            });
            const pore = new THREE.Mesh(poreGeometry, poreMaterial);
            
            // Voltage sensor domains
            for (let i = 0; i < 4; i++) {
                const sensorGeometry = new THREE.BoxGeometry(0.04, 0.04, 0.15);
                const sensorMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF6600
                });
                const sensor = new THREE.Mesh(sensorGeometry, sensorMaterial);
                
                const angle = (i / 4) * Math.PI * 2;
                sensor.position.x = Math.cos(angle) * 0.06;
                sensor.position.y = Math.sin(angle) * 0.06;
                
                channelGroup.add(sensor);
            }
            
            channelGroup.add(pore);
            channelGroup.userData = { type: 'calciumChannel', state: 'closed' };
            
            return channelGroup;
        }
        
        function createPotassiumChannel() {
            const channelGroup = new THREE.Group();
            channelGroup.name = 'potassiumChannel';
            
            // Main channel structure
            const channelGeometry = new THREE.CylinderGeometry(0.025, 0.025, 0.18, 6);
            const channelMaterial = new THREE.MeshPhongMaterial({
                color: 0x9966FF,
                transparent: true,
                opacity: 0.8
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            
            // Selectivity filter (narrow region)
            const filterGeometry = new THREE.CylinderGeometry(0.015, 0.015, 0.05, 6);
            const filterMaterial = new THREE.MeshPhongMaterial({
                color: 0x6633CC
            });
            const filter = new THREE.Mesh(filterGeometry, filterMaterial);
            
            channelGroup.add(channel, filter);
            channelGroup.userData = { type: 'potassiumChannel' };
            
            return channelGroup;
        }
        
        function createIonChannels(membraneGroup) {
            const ionChannelsGroup = new THREE.Group();
            ionChannelsGroup.name = 'ionChannels';
            
            // Sodium channels
            for (let i = 0; i < 20; i++) {
                const sodiumChannel = createSodiumChannel();
                positionOnMembrane(sodiumChannel, 6.0);
                ionChannelsGroup.add(sodiumChannel);
            }
            
            // Chloride channels
            for (let i = 0; i < 15; i++) {
                const chlorideChannel = createChlorideChannel();
                positionOnMembrane(chlorideChannel, 6.0);
                ionChannelsGroup.add(chlorideChannel);
            }
            
            membraneGroup.add(ionChannelsGroup);
        }
        
        function createSodiumChannel() {
            const channelGroup = new THREE.Group();
            channelGroup.name = 'sodiumChannel';
            
            const channelGeometry = new THREE.CylinderGeometry(0.028, 0.028, 0.2, 8);
            const channelMaterial = new THREE.MeshPhongMaterial({
                color: 0x00FF88,
                transparent: true,
                opacity: 0.8
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            
            // Inactivation gate
            const gateGeometry = new THREE.SphereGeometry(0.02, 6, 6);
            const gateMaterial = new THREE.MeshPhongMaterial({
                color: 0x00CC66
            });
            const gate = new THREE.Mesh(gateGeometry, gateMaterial);
            gate.position.y = 0.12;
            
            channelGroup.add(channel, gate);
            channelGroup.userData = { type: 'sodiumChannel', state: 'closed' };
            
            return channelGroup;
        }
        
        function createChlorideChannel() {
            const channelGroup = new THREE.Group();
            channelGroup.name = 'chlorideChannel';
            
            const channelGeometry = new THREE.CylinderGeometry(0.022, 0.022, 0.16, 6);
            const channelMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF8800,
                transparent: true,
                opacity: 0.8
            });
            const channel = new THREE.Mesh(channelGeometry, channelMaterial);
            
            channelGroup.add(channel);
            channelGroup.userData = { type: 'chlorideChannel' };
            
            return channelGroup;
        }
        
        function createGlucoseTransporters(membraneGroup) {
            const transportersGroup = new THREE.Group();
            transportersGroup.name = 'glucoseTransporters';
            
            // GLUT transporters
            for (let i = 0; i < 30; i++) {
                const transporter = createGLUTTransporter();
                positionOnMembrane(transporter, 6.0);
                transportersGroup.add(transporter);
            }
            
            membraneGroup.add(transportersGroup);
        }
        
        function createGLUTTransporter() {
            const transporterGroup = new THREE.Group();
            transporterGroup.name = 'glutTransporter';
            
            // Main transporter structure (12 transmembrane domains)
            const mainGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.24, 12);
            const mainMaterial = new THREE.MeshPhongMaterial({
                color: 0x00FFAA,
                transparent: true,
                opacity: 0.85
            });
            const mainStructure = new THREE.Mesh(mainGeometry, mainMaterial);
            
            // Glucose binding site
            const bindingSiteGeometry = new THREE.SphereGeometry(0.025, 8, 8);
            const bindingSiteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFFF00,
                emissive: 0x333300
            });
            const bindingSite = new THREE.Mesh(bindingSiteGeometry, bindingSiteMaterial);
            
            transporterGroup.add(mainStructure, bindingSite);
            transporterGroup.userData = { 
                type: 'glutTransporter',
                conformationState: 'outward-facing',
                animationPhase: Math.random() * Math.PI * 2
            };
            
            return transporterGroup;
        }
        
        function createAminoAcidTransporters(membraneGroup) {
            const transportersGroup = new THREE.Group();
            transportersGroup.name = 'aminoAcidTransporters';
            
            // LAT1 transporters (leucine transporter)
            for (let i = 0; i < 20; i++) {
                const transporter = createLATTransporter();
                positionOnMembrane(transporter, 6.0);
                transportersGroup.add(transporter);
            }
            
            // System A transporters (alanine, serine, cysteine)
            for (let i = 0; i < 15; i++) {
                const transporter = createSystemATransporter();
                positionOnMembrane(transporter, 6.0);
                transportersGroup.add(transporter);
            }
            
            membraneGroup.add(transportersGroup);
        }
        
        function createLATTransporter() {
            const transporterGroup = new THREE.Group();
            transporterGroup.name = 'latTransporter';
            
            const transporterGeometry = new THREE.CylinderGeometry(0.055, 0.055, 0.22, 10);
            const transporterMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF6699,
                transparent: true,
                opacity: 0.8
            });
            const transporter = new THREE.Mesh(transporterGeometry, transporterMaterial);
            
            // Amino acid binding site
            const bindingSiteGeometry = new THREE.BoxGeometry(0.03, 0.03, 0.03);
            const bindingSiteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFCC00
            });
            const bindingSite = new THREE.Mesh(bindingSiteGeometry, bindingSiteMaterial);
            
            transporterGroup.add(transporter, bindingSite);
            transporterGroup.userData = { type: 'latTransporter' };
            
            return transporterGroup;
        }
        
        function createSystemATransporter() {
            const transporterGroup = new THREE.Group();
            transporterGroup.name = 'systemATransporter';
            
            const transporterGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8);
            const transporterMaterial = new THREE.MeshPhongMaterial({
                color: 0x66CCFF,
                transparent: true,
                opacity: 0.8
            });
            const transporter = new THREE.Mesh(transporterGeometry, transporterMaterial);
            
            transporterGroup.add(transporter);
            transporterGroup.userData = { type: 'systemATransporter' };
            
            return transporterGroup;
        }
        
        function positionOnMembrane(object, radius) {
            const phi = Math.random() * Math.PI;
            const theta = Math.random() * Math.PI * 2;
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            object.position.set(x, y, z);
            object.lookAt(new THREE.Vector3(0, 0, 0));
        }
        
        function createCytoplasm() {
            // Create layered cytoplasm with different densities
            const cytoplasmGroup = new THREE.Group();
            cytoplasmGroup.name = 'cytoplasm';
            
            // Outer cytoplasm (cortical region) - more dense - com corte em 3/4 - cores mais vibrantes
            const outerGeometry = new THREE.SphereGeometry(5.8, 32, 32, 0, Math.PI * 1.5);
            const outerMaterial = new THREE.MeshPhongMaterial({
                color: 0xDA70D6,  // Orqu√≠dea vibrante
                transparent: true,
                opacity: 0.25,    // Mais vis√≠vel
                shininess: 50,
                specular: 0xFFFFFF
            });
            const outerCytoplasm = new THREE.Mesh(outerGeometry, outerMaterial);
            
            // Middle cytoplasm - intermediate density - com corte em 3/4 - cores mais vibrantes
            const middleGeometry = new THREE.SphereGeometry(4.5, 32, 32, 0, Math.PI * 1.5);
            const middleMaterial = new THREE.MeshPhongMaterial({
                color: 0xBA55D3,  // Orqu√≠dea m√©dia
                transparent: true,
                opacity: 0.22,    // Mais vis√≠vel
                shininess: 60,
                specular: 0xFFFFFF
            });
            const middleCytoplasm = new THREE.Mesh(middleGeometry, middleMaterial);
            
            // Inner cytoplasm (perinuclear region) - less dense, more organized - com corte em 3/4 - cores mais vibrantes
            const innerGeometry = new THREE.SphereGeometry(3.0, 32, 32, 0, Math.PI * 1.5);
            const innerMaterial = new THREE.MeshPhongMaterial({
                color: 0x9932CC,  // Orqu√≠dea escura
                transparent: true,
                opacity: 0.18,    // Mais vis√≠vel
                shininess: 70,
                specular: 0xFFFFFF
            });
            const innerCytoplasm = new THREE.Mesh(innerGeometry, innerMaterial);
            
            cytoplasmGroup.add(outerCytoplasm, middleCytoplasm, innerCytoplasm);
            oocyteGroup.add(cytoplasmGroup);
        }
        
        function createNucleus() {
            // Create nucleus with nuclear envelope and condensed chromosomes
            const nucleusMainGroup = new THREE.Group();
            
            // Position nucleus centrally (slightly off-center as in real oocytes)
            nucleusMainGroup.position.set(0, 0, 0);
            
            // Nuclear envelope (double membrane) - larger and more realistic - com corte em 3/4 - cores mais vibrantes
            const outerEnvelopeGeometry = new THREE.SphereGeometry(1.65, 64, 32, 0, Math.PI * 1.5);
            const outerEnvelopeMaterial = new THREE.MeshPhongMaterial({
                color: 0x9400D3,  // Violeta vibrante
                transparent: true,
                opacity: 0.6,     // Mais vis√≠vel
                side: THREE.DoubleSide,
                shininess: 100,
                specular: 0xFFFFFF
            });
            const outerEnvelope = new THREE.Mesh(outerEnvelopeGeometry, outerEnvelopeMaterial);
            
            const innerEnvelopeGeometry = new THREE.SphereGeometry(1.58, 64, 32, 0, Math.PI * 1.5);
            const innerEnvelopeMaterial = new THREE.MeshPhongMaterial({
                color: 0x6A5ACD,  // Azul ard√≥sia m√©dio
                transparent: true,
                opacity: 0.45,
                side: THREE.DoubleSide
            });
            const innerEnvelope = new THREE.Mesh(innerEnvelopeGeometry, innerEnvelopeMaterial);
            
            // Nuclear pores (more realistic distribution and count)
            for (let i = 0; i < 60; i++) {
                // Nuclear pore complex structure
                const poreComplexGroup = new THREE.Group();
                
                // Central channel
                const poreGeometry = new THREE.CylinderGeometry(0.04, 0.04, 0.12, 8);
                const poreMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x1A5490,
                    transparent: true,
                    opacity: 0.8
                });
                const pore = new THREE.Mesh(poreGeometry, poreMaterial);
                
                // Cytoplasmic ring
                const cytoRingGeometry = new THREE.TorusGeometry(0.08, 0.015, 6, 12);
                const cytoRingMaterial = new THREE.MeshPhongMaterial({ color: 0x0F4C75 });
                const cytoRing = new THREE.Mesh(cytoRingGeometry, cytoRingMaterial);
                cytoRing.position.z = 0.06;
                
                // Nuclear ring
                const nucRingGeometry = new THREE.TorusGeometry(0.08, 0.015, 6, 12);
                const nucRingMaterial = new THREE.MeshPhongMaterial({ color: 0x0F4C75 });
                const nucRing = new THREE.Mesh(nucRingGeometry, nucRingMaterial);
                nucRing.position.z = -0.06;
                
                poreComplexGroup.add(pore, cytoRing, nucRing);
                
                // Position on nuclear envelope
                const phi = Math.random() * Math.PI;
                const theta = Math.random() * Math.PI * 2;
                const radius = 1.61;
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                poreComplexGroup.position.set(x, y, z);
                poreComplexGroup.lookAt(new THREE.Vector3(0, 0, 0));
                nucleusMainGroup.add(poreComplexGroup);
            }
            
            // Condensed chromosomes (23 pairs for human oocyte) - more organized and realistic
            const chromosomeClusterGroup = new THREE.Group();
            chromosomeClusterGroup.name = 'chromosomeCluster';
            
            // Create chromosomes in a more organized cluster (not in spindle formation)
            for (let i = 0; i < 23; i++) {
                const chromosomeGroup = new THREE.Group();
                chromosomeGroup.name = `chromosome_${i + 1}`;
                
                // Create more realistic condensed chromosome structure
                const chromosomeLength = 0.4 + Math.random() * 0.2;
                const chromosomeWidth = 0.04;
                
                // Sister chromatids
                const chromatid1Geometry = new THREE.CylinderGeometry(chromosomeWidth, chromosomeWidth, chromosomeLength, 8);
                const chromatid2Geometry = new THREE.CylinderGeometry(chromosomeWidth, chromosomeWidth, chromosomeLength, 8);
                
                const chromatidMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x6A1B9A,
                    shininess: 30
                });
                
                const chromatid1 = new THREE.Mesh(chromatid1Geometry, chromatidMaterial);
                const chromatid2 = new THREE.Mesh(chromatid2Geometry, chromatidMaterial);
                
                // Position sister chromatids side by side
                chromatid1.position.x = -chromosomeWidth * 0.6;
                chromatid2.position.x = chromosomeWidth * 0.6;
                
                // Centromere connecting the chromatids
                const centromereGeometry = new THREE.SphereGeometry(chromosomeWidth * 1.5, 8, 6);
                const centromereMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4A148C,
                    emissive: 0x1A0A2E
                });
                const centromere = new THREE.Mesh(centromereGeometry, centromereMaterial);
                
                // Cinet√≥coros fixados nos centr√¥meros - Estrutura complexa e real√≠stica
                const kinetochoreGroup1 = new THREE.Group();
                const kinetochoreGroup2 = new THREE.Group();
                
                // Criar cinet√≥coros para cada crom√°tide irm√£
                for (let k = 0; k < 2; k++) {
                    const kinetochoreGroup = k === 0 ? kinetochoreGroup1 : kinetochoreGroup2;
                    
                    // Placa interna do cinet√≥coro (ligada ao centr√¥mero)
                    const innerPlateGeometry = new THREE.CylinderGeometry(chromosomeWidth * 0.7, chromosomeWidth * 0.7, chromosomeWidth * 0.2, 8);
                    const innerPlateMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFF4500,  // Vermelho-laranja
                        emissive: 0x331100,
                        emissiveIntensity: 0.2
                    });
                    const innerPlate = new THREE.Mesh(innerPlateGeometry, innerPlateMaterial);
                    kinetochoreGroup.add(innerPlate);
                    
                    // Placa externa do cinet√≥coro (onde se ligam os microt√∫bulos)
                    const outerPlateGeometry = new THREE.CylinderGeometry(chromosomeWidth * 0.9, chromosomeWidth * 0.9, chromosomeWidth * 0.15, 8);
                    const outerPlateMaterial = new THREE.MeshPhongMaterial({ 
                        color: 0xFF6347,  // Tomate
                        emissive: 0x221100,
                        emissiveIntensity: 0.15
                    });
                    const outerPlate = new THREE.Mesh(outerPlateGeometry, outerPlateMaterial);
                    outerPlate.position.z = chromosomeWidth * 0.4;
                    kinetochoreGroup.add(outerPlate);
                    
                    // Prote√≠nas do cinet√≥coro (pontos de liga√ß√£o dos microt√∫bulos)
                    for (let p = 0; p < 8; p++) {
                        const proteinGeometry = new THREE.SphereGeometry(chromosomeWidth * 0.15, 6, 6);
                        const proteinMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0xFFD700,  // Dourado
                            emissive: 0x332200,
                            emissiveIntensity: 0.1
                        });
                        const protein = new THREE.Mesh(proteinGeometry, proteinMaterial);
                        
                        const angle = (p / 8) * Math.PI * 2;
                        protein.position.x = Math.cos(angle) * chromosomeWidth * 0.6;
                        protein.position.y = Math.sin(angle) * chromosomeWidth * 0.6;
                        protein.position.z = chromosomeWidth * 0.5;
                        
                        kinetochoreGroup.add(protein);
                    }
                    
                    // Fibras do cinet√≥coro (conex√µes com microt√∫bulos)
                    for (let f = 0; f < 6; f++) {
                        const fiberGeometry = new THREE.CylinderGeometry(chromosomeWidth * 0.05, chromosomeWidth * 0.05, chromosomeWidth * 0.8, 4);
                        const fiberMaterial = new THREE.MeshPhongMaterial({ 
                            color: 0x00CED1,  // Turquesa escuro
                            transparent: true,
                            opacity: 0.8
                        });
                        const fiber = new THREE.Mesh(fiberGeometry, fiberMaterial);
                        
                        const angle = (f / 6) * Math.PI * 2;
                        fiber.position.x = Math.cos(angle) * chromosomeWidth * 0.3;
                        fiber.position.y = Math.sin(angle) * chromosomeWidth * 0.3;
                        fiber.position.z = chromosomeWidth * 0.8;
                        fiber.rotation.x = Math.random() * 0.3;
                        fiber.rotation.y = Math.random() * 0.3;
                        
                        kinetochoreGroup.add(fiber);
                    }
                }
                
                // Posicionar cinet√≥coros nas crom√°tides irm√£s
                kinetochoreGroup1.position.set(-chromosomeWidth * 0.6, 0, chromosomeWidth * 1.2);
                kinetochoreGroup2.position.set(chromosomeWidth * 0.6, 0, chromosomeWidth * 1.2);
                
                const kinetochore1 = kinetochoreGroup1;
                const kinetochore2 = kinetochoreGroup2;
                
                chromosomeGroup.add(chromatid1, chromatid2, centromere, kinetochore1, kinetochore2);
                
                // Position chromosomes in a clustered arrangement (not aligned)
                const clusterRadius = 0.8;
                const angle = (i / 23) * Math.PI * 2 + Math.random() * 0.5;
                const height = (Math.random() - 0.5) * 0.6;
                const radius = clusterRadius * (0.3 + Math.random() * 0.7);
                
                const x = Math.cos(angle) * radius;
                const y = height;
                const z = Math.sin(angle) * radius;
                
                chromosomeGroup.position.set(x, y, z);
                
                // Random orientation (condensed, not aligned)
                chromosomeGroup.rotation.x = Math.random() * Math.PI;
                chromosomeGroup.rotation.y = Math.random() * Math.PI;
                chromosomeGroup.rotation.z = Math.random() * Math.PI;
                
                chromosomeClusterGroup.add(chromosomeGroup);
            }
            
            // Position chromosome cluster slightly off-center
            chromosomeClusterGroup.position.set(0.2, -0.1, 0.1);
            nucleusMainGroup.add(chromosomeClusterGroup);
            
            // Nucleolus
            const nucleolusGeometry = new THREE.SphereGeometry(0.3, 16, 12);
            const nucleolusMaterial = new THREE.MeshPhongMaterial({ color: 0x191970 });
            const nucleolus = new THREE.Mesh(nucleolusGeometry, nucleolusMaterial);
            nucleolus.position.set(0.5, 0.3, -0.2);
            
            nucleusMainGroup.add(outerEnvelope, innerEnvelope, nucleolus);
            nucleusGroup.add(nucleusMainGroup);
        }
        
        function createCentrosomesAndSpindle() {
            // Centrosomes at opposite poles
            const poleDistance = 4;
            const centrosomePositions = [
                {x: 0, y: poleDistance, z: 0},
                {x: 0, y: -poleDistance, z: 0}
            ];
            
            centrosomePositions.forEach((pos, index) => {
                // Centrosome main body
                const centrosomeGeometry = new THREE.SphereGeometry(0.15, 16, 16);
                const centrosomeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00FF7F,
                    emissive: 0x002211
                });
                const centrosome = new THREE.Mesh(centrosomeGeometry, centrosomeMaterial);
                centrosome.position.set(pos.x, pos.y, pos.z);
                centrosome.name = 'centrosome';
                nucleusGroup.add(centrosome);
                
                // Centrioles (two perpendicular cylinders)
                for (let i = 0; i < 2; i++) {
                    const centrioleGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.2, 8);
                    const centrioleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x32CD32
                    });
                    const centriole = new THREE.Mesh(centrioleGeometry, centrioleMaterial);
                    centriole.position.set(pos.x, pos.y, pos.z);
                    centriole.rotation.x = i * Math.PI/2;
                    centriole.rotation.z = i * Math.PI/2;
                    nucleusGroup.add(centriole);
                }
            });
            
            // Microt√∫bulos do fuso mei√≥tico compostos de tubulina Œ±/Œ≤
            // Estrutura mais real√≠stica com protofilamentos e heterod√≠meros
            const chromosomeRadius = 0.8;
            for (let i = 0; i < 23; i++) {
                const angle = (i / 23) * Math.PI * 2;
                const chromosomeX = Math.cos(angle) * chromosomeRadius;
                const chromosomeZ = Math.sin(angle) * chromosomeRadius;
                
                // Microt√∫bulos de cada centrossomo para cromossomo
                centrosomePositions.forEach((centrosome, poleIndex) => {
                    const start = new THREE.Vector3(centrosome.x, centrosome.y, centrosome.z);
                    const end = new THREE.Vector3(chromosomeX, 0, chromosomeZ);
                    const distance = start.distanceTo(end);
                    
                    // Grupo para o microt√∫bulo completo
                    const microtubuleGroup = new THREE.Group();
                    
                    // Microt√∫bulo principal (13 protofilamentos)
                    const mainTubuleGeometry = new THREE.CylinderGeometry(0.012, 0.012, distance, 13);
                    const mainTubuleMaterial = new THREE.MeshPhongMaterial({
                        color: 0x00BFFF,  // Azul c√©u profundo
                        transparent: true,
                        opacity: 0.8,
                        emissive: 0x001122,
                        emissiveIntensity: 0.1,
                        shininess: 60
                    });
                    const mainTubule = new THREE.Mesh(mainTubuleGeometry, mainTubuleMaterial);
                    microtubuleGroup.add(mainTubule);
                    
                    // Protofilamentos individuais (tubulina Œ±/Œ≤)
                    for (let p = 0; p < 13; p++) {
                        const protoAngle = (p / 13) * Math.PI * 2;
                        const protoRadius = 0.011;
                        
                        // Heterod√≠meros de tubulina Œ±/Œ≤ ao longo do protofilamento
                        for (let h = 0; h < Math.floor(distance * 15); h++) {
                            const heteroDimerGroup = new THREE.Group();
                            
                            // Tubulina Œ± (subunidade)
                            const tubulinAlphaGeometry = new THREE.SphereGeometry(0.003, 6, 6);
                            const tubulinAlphaMaterial = new THREE.MeshPhongMaterial({
                                color: 0xFF6347,  // Vermelho tomate para Œ±
                                emissive: 0x220000,
                                emissiveIntensity: 0.05
                            });
                            const tubulinAlpha = new THREE.Mesh(tubulinAlphaGeometry, tubulinAlphaMaterial);
                            tubulinAlpha.position.z = -0.002;
                            heteroDimerGroup.add(tubulinAlpha);
                            
                            // Tubulina Œ≤ (subunidade)
                            const tubulinBetaGeometry = new THREE.SphereGeometry(0.003, 6, 6);
                            const tubulinBetaMaterial = new THREE.MeshPhongMaterial({
                                color: 0x32CD32,  // Verde lima para Œ≤
                                emissive: 0x002200,
                                emissiveIntensity: 0.05
                            });
                            const tubulinBeta = new THREE.Mesh(tubulinBetaGeometry, tubulinBetaMaterial);
                            tubulinBeta.position.z = 0.002;
                            heteroDimerGroup.add(tubulinBeta);
                            
                            // Posicionar heterod√≠mero no protofilamento
                            heteroDimerGroup.position.x = Math.cos(protoAngle) * protoRadius;
                            heteroDimerGroup.position.y = Math.sin(protoAngle) * protoRadius;
                            heteroDimerGroup.position.z = (h / (distance * 15) - 0.5) * distance;
                            
                            // Adicionar apenas alguns heterod√≠meros para n√£o sobrecarregar
                            if (h % 3 === 0) {
                                microtubuleGroup.add(heteroDimerGroup);
                            }
                        }
                    }
                    
                    // Prote√≠nas associadas aos microt√∫bulos (MAPs)
                    for (let m = 0; m < 8; m++) {
                        const mapGeometry = new THREE.SphereGeometry(0.004, 6, 6);
                        const mapMaterial = new THREE.MeshPhongMaterial({
                            color: 0xFFD700,  // Dourado para MAPs
                            emissive: 0x332200,
                            emissiveIntensity: 0.1
                        });
                        const map = new THREE.Mesh(mapGeometry, mapMaterial);
                        
                        const mapAngle = Math.random() * Math.PI * 2;
                        const mapPosition = Math.random() * distance - distance/2;
                        map.position.x = Math.cos(mapAngle) * 0.015;
                        map.position.y = Math.sin(mapAngle) * 0.015;
                        map.position.z = mapPosition;
                        
                        microtubuleGroup.add(map);
                    }
                    
                    // Posicionar e orientar o microt√∫bulo
                    const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
                    microtubuleGroup.position.copy(midpoint);
                    microtubuleGroup.lookAt(end);
                    microtubuleGroup.rotateX(Math.PI / 2);
                    
                    microtubuleGroup.name = `microtubule_chr${i}_pole${poleIndex}`;
                    nucleusGroup.add(microtubuleGroup);
                });
            }
            
            // Additional astral microtubules radiating from centrosomes
            centrosomePositions.forEach(pos => {
                for (let i = 0; i < 12; i++) {
                    const angle = (i / 12) * Math.PI * 2;
                    const length = 1.5;
                    
                    const astralGeometry = new THREE.CylinderGeometry(0.005, 0.005, length, 4);
                    const astralMaterial = new THREE.MeshBasicMaterial({
                        color: 0x00CCCC,
                        transparent: true,
                        opacity: 0.4
                    });
                    const astral = new THREE.Mesh(astralGeometry, astralMaterial);
                    
                    astral.position.set(pos.x, pos.y, pos.z);
                    astral.rotation.z = angle;
                    astral.rotation.x = Math.PI/2;
                    
                    nucleusGroup.add(astral);
                }
            });
        }
        
        function createMitochondrion() {
            const mitochondriaGroup = new THREE.Group();
            mitochondriaGroup.name = 'mitochondrion';
            
            // Outer membrane (coral/orange like in reference image) - using ellipsoid shape
            const outerMembraneGeometry = new THREE.SphereGeometry(0.12, 16, 8);
            outerMembraneGeometry.scale(1, 2.5, 1); // Make it elongated like a mitochondrion
            const outerMembraneMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF7F50,  // Coral vibrante como na imagem
                shininess: 90,
                specular: 0x888888,
                emissive: 0x331100,
                transparent: true,
                opacity: 0.85,
                side: THREE.DoubleSide
            });
            const outerMembrane = new THREE.Mesh(outerMembraneGeometry, outerMembraneMaterial);
            mitochondriaGroup.add(outerMembrane);
            
            // Inner membrane space (slightly smaller)
            const innerSpaceGeometry = new THREE.SphereGeometry(0.10, 16, 8);
            innerSpaceGeometry.scale(1, 2.3, 1); // Slightly smaller elongated shape
            const innerSpaceMaterial = new THREE.MeshPhongMaterial({
                color: 0x4169E1,  // Azul royal para o espa√ßo interno
                transparent: true,
                opacity: 0.6,
                emissive: 0x001133,
                shininess: 100
            });
            const innerSpace = new THREE.Mesh(innerSpaceGeometry, innerSpaceMaterial);
            mitochondriaGroup.add(innerSpace);
            
            // Cristae (internal membrane folds) - detailed like in reference
            const cristaeCount = 8;
            for (let j = 0; j < cristaeCount; j++) {
                // Create curved cristae using multiple segments
                const cristaeGroup = new THREE.Group();
                
                // Main cristae structure
                const cristaeGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.02, 8);
                const cristaeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x6A5ACD,  // Roxo azulado como na imagem
                    transparent: true,
                    opacity: 0.9,
                    emissive: 0x221144,
                    shininess: 120,
                    metalness: 0.2
                });
                
                // Create folded cristae structure
                for (let k = 0; k < 3; k++) {
                    const cristae = new THREE.Mesh(cristaeGeometry, cristaeMaterial);
                    cristae.position.set(
                        Math.sin(k * Math.PI / 3) * 0.04,
                        (j - cristaeCount/2) * 0.06,
                        Math.cos(k * Math.PI / 3) * 0.04
                    );
                    cristae.rotation.x = k * Math.PI / 6;
                    cristae.rotation.y = j * Math.PI / 4;
                    cristaeGroup.add(cristae);
                }
                
                // Add connecting membranes
                const connectionGeometry = new THREE.PlaneGeometry(0.15, 0.03);
                const connectionMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8A2BE2,  // Roxo mais vibrante
                    transparent: true,
                    opacity: 0.7,
                    side: THREE.DoubleSide,
                    emissive: 0x220044
                });
                const connection = new THREE.Mesh(connectionGeometry, connectionMaterial);
                connection.position.y = (j - cristaeCount/2) * 0.06;
                connection.rotation.y = j * Math.PI / 4;
                cristaeGroup.add(connection);
                
                mitochondriaGroup.add(cristaeGroup);
            }
            
            // Matrix granules (more detailed and realistic)
            for (let k = 0; k < 5; k++) {
                const granuleGeometry = new THREE.SphereGeometry(0.008, 8, 8);
                const granuleMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFE4B5,  // Bege claro para os gr√¢nulos
                    emissive: 0x332211,
                    shininess: 150,
                    metalness: 0.1
                });
                const granule = new THREE.Mesh(granuleGeometry, granuleMaterial);
                granule.position.set(
                    (Math.random() - 0.5) * 0.15,
                    (Math.random() - 0.5) * 0.4,
                    (Math.random() - 0.5) * 0.15
                );
                mitochondriaGroup.add(granule);
            }
            
            // Add ribosomes on outer membrane
            for (let r = 0; r < 8; r++) {
                const ribosomeGeometry = new THREE.SphereGeometry(0.005, 6, 6);
                const ribosomeMaterial = new THREE.MeshPhongMaterial({
                    color: 0xDDA0DD,  // Roxo claro
                    emissive: 0x221122,
                    shininess: 80
                });
                const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);
                
                // Position on outer membrane surface
                const angle = (r / 8) * Math.PI * 2;
                const height = (Math.random() - 0.5) * 0.4;
                ribosome.position.set(
                    Math.cos(angle) * 0.13,
                    height,
                    Math.sin(angle) * 0.13
                );
                mitochondriaGroup.add(ribosome);
            }
            
            return mitochondriaGroup;
        }
        
        function createCytoskeleton() {
            const cytoskeletonGroup = new THREE.Group();
            cytoskeletonGroup.name = 'cytoskeleton';
            
            // Microtubule network - organized radially from centrosome
            const microtubuleGroup = new THREE.Group();
            
            // Main microtubule organizing center (MTOC)
            const centrosomeGeometry = new THREE.SphereGeometry(0.15, 12, 12);
            const centrosomeMaterial = new THREE.MeshPhongMaterial({
                color: 0x8A2BE2,
                emissive: 0x220044
            });
            const centrosome = new THREE.Mesh(centrosomeGeometry, centrosomeMaterial);
            centrosome.position.set(1.5, 0, 1.5); // Positioned near nucleus but in cytoplasm
            microtubuleGroup.add(centrosome);
            
            // Radial microtubules extending from MTOC
            for (let i = 0; i < 30; i++) {
                const mtGeometry = new THREE.CylinderGeometry(0.008, 0.008, 3.5, 6);
                const mtMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00FF7F,
                    transparent: true,
                    opacity: 0.8
                });
                const microtubule = new THREE.Mesh(mtGeometry, mtMaterial);
                
                // Radial distribution from centrosome
                const angle = (i / 30) * Math.PI * 2;
                const elevation = (Math.random() - 0.5) * Math.PI / 3;
                
                microtubule.position.copy(centrosome.position);
                microtubule.rotation.z = angle;
                microtubule.rotation.x = elevation;
                
                // Extend outward
                const direction = new THREE.Vector3(
                    Math.cos(angle) * Math.cos(elevation),
                    Math.sin(elevation),
                    Math.sin(angle) * Math.cos(elevation)
                );
                microtubule.position.add(direction.multiplyScalar(1.75));
                
                microtubuleGroup.add(microtubule);
            }
            
            // Cortical microtubules (parallel to cell membrane)
            for (let i = 0; i < 25; i++) {
                const corticalMtGeometry = new THREE.CylinderGeometry(0.006, 0.006, 2.0, 6);
                const corticalMtMaterial = new THREE.MeshPhongMaterial({
                    color: 0x32CD32,
                    transparent: true,
                    opacity: 0.7
                });
                const corticalMt = new THREE.Mesh(corticalMtGeometry, corticalMtMaterial);
                
                // Position near cortex
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 4.2;
                
                corticalMt.position.x = radius * Math.sin(phi) * Math.cos(theta);
                corticalMt.position.y = radius * Math.sin(phi) * Math.sin(theta);
                corticalMt.position.z = radius * Math.cos(phi);
                
                // Orient tangentially to surface
                corticalMt.rotation.x = Math.random() * Math.PI;
                corticalMt.rotation.y = Math.random() * Math.PI;
                
                microtubuleGroup.add(corticalMt);
            }
            
            cytoskeletonGroup.add(microtubuleGroup);
            
            // Actin filament network - concentrated at cortex
            const actinGroup = new THREE.Group();
            
            // Cortical actin network (dense at cell periphery)
            for (let i = 0; i < 80; i++) {
                const actinGeometry = new THREE.CylinderGeometry(0.003, 0.003, 1.2, 4);
                const actinMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF1493,
                    transparent: true,
                    opacity: 0.6
                });
                const actinFilament = new THREE.Mesh(actinGeometry, actinMaterial);
                
                // Dense cortical network
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 4.6 + Math.random() * 0.3;
                
                actinFilament.position.x = radius * Math.sin(phi) * Math.cos(theta);
                actinFilament.position.y = radius * Math.sin(phi) * Math.sin(theta);
                actinFilament.position.z = radius * Math.cos(phi);
                
                // Random orientation for mesh-like network
                actinFilament.rotation.x = Math.random() * Math.PI;
                actinFilament.rotation.y = Math.random() * Math.PI;
                actinFilament.rotation.z = Math.random() * Math.PI;
                
                actinGroup.add(actinFilament);
            }
            
            // Stress fibers (organized actin bundles)
            for (let i = 0; i < 15; i++) {
                const stressFiberGeometry = new THREE.CylinderGeometry(0.008, 0.008, 4.0, 6);
                const stressFiberMaterial = new THREE.MeshPhongMaterial({
                    color: 0xDC143C,
                    transparent: true,
                    opacity: 0.8
                });
                const stressFiber = new THREE.Mesh(stressFiberGeometry, stressFiberMaterial);
                
                // Cross-cytoplasmic organization
                const angle = (i / 15) * Math.PI;
                stressFiber.rotation.y = angle;
                stressFiber.rotation.z = (Math.random() - 0.5) * Math.PI / 4;
                
                // Position in mid-cytoplasm
                stressFiber.position.x = (Math.random() - 0.5) * 2.0;
                stressFiber.position.y = (Math.random() - 0.5) * 2.0;
                stressFiber.position.z = (Math.random() - 0.5) * 2.0;
                
                actinGroup.add(stressFiber);
            }
            
            cytoskeletonGroup.add(actinGroup);
            
            // Intermediate filaments (keratin network)
            const intermediateGroup = new THREE.Group();
            
            for (let i = 0; i < 40; i++) {
                const ifGeometry = new THREE.CylinderGeometry(0.005, 0.005, 2.5, 6);
                const ifMaterial = new THREE.MeshPhongMaterial({
                    color: 0x9370DB,
                    transparent: true,
                    opacity: 0.5
                });
                const intermediateFilament = new THREE.Mesh(ifGeometry, ifMaterial);
                
                // Network throughout cytoplasm
                const radius = 1.5 + Math.random() * 2.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                intermediateFilament.position.x = radius * Math.sin(phi) * Math.cos(theta);
                intermediateFilament.position.y = radius * Math.sin(phi) * Math.sin(theta);
                intermediateFilament.position.z = radius * Math.cos(phi);
                
                intermediateFilament.rotation.x = Math.random() * Math.PI;
                intermediateFilament.rotation.y = Math.random() * Math.PI;
                intermediateFilament.rotation.z = Math.random() * Math.PI;
                
                intermediateGroup.add(intermediateFilament);
            }
            
            cytoskeletonGroup.add(intermediateGroup);
            
            return cytoskeletonGroup;
        }
        
        function createOrganelles() {
            // Enhanced Mitochondria with realistic distribution based on oocyte structure
            // Create organized clusters and networks as seen in real oocytes
            
            // Perinuclear mitochondrial cluster (around nucleus)
            for (let i = 0; i < 60; i++) {
                const mitochondrion = createMitochondrion();
                
                // Position around nucleus in organized manner
                const angle = (i / 60) * Math.PI * 2;
                const height = (Math.random() - 0.5) * 1.0;
                const radius = 2.2 + Math.random() * 0.8; // Around nuclear envelope
                
                mitochondrion.position.x = Math.cos(angle) * radius;
                mitochondrion.position.y = height;
                mitochondrion.position.z = Math.sin(angle) * radius;
                
                // Orient towards nucleus
                mitochondrion.lookAt(new THREE.Vector3(0, 0, 0));
                organellesGroup.add(mitochondrion);
            }
            
            // Cortical mitochondrial network (near cell membrane)
            for (let i = 0; i < 80; i++) {
                const mitochondrion = createMitochondrion();
                
                // Position in cortical region with some organization
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 4.5 + Math.random() * 0.8; // Near cortex but inside cytoplasm
                
                mitochondrion.position.x = radius * Math.sin(phi) * Math.cos(theta);
                mitochondrion.position.y = radius * Math.sin(phi) * Math.sin(theta);
                mitochondrion.position.z = radius * Math.cos(phi);
                
                // Random orientation for cortical mitochondria
                mitochondrion.rotation.x = Math.random() * Math.PI;
                mitochondrion.rotation.y = Math.random() * Math.PI;
                mitochondrion.rotation.z = Math.random() * Math.PI;
                
                organellesGroup.add(mitochondrion);
            }
            
            // Scattered mitochondria throughout cytoplasm
            for (let i = 0; i < 40; i++) {
                const mitochondrion = createMitochondrion();
                
                // Random distribution in intermediate cytoplasm
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 2.8 + Math.random() * 1.5;
                
                mitochondrion.position.x = radius * Math.sin(phi) * Math.cos(theta);
                mitochondrion.position.y = radius * Math.sin(phi) * Math.sin(theta);
                mitochondrion.position.z = radius * Math.cos(phi);
                
                mitochondrion.rotation.x = Math.random() * Math.PI;
                mitochondrion.rotation.y = Math.random() * Math.PI;
                mitochondrion.rotation.z = Math.random() * Math.PI;
                
                organellesGroup.add(mitochondrion);
            }
            
            // Enhanced Endoplasmic Reticulum Network - Realistic folded structure around nucleus
            // Create main ER network extending from nuclear envelope
            const erNetworkGroup = new THREE.Group();
            
            // Rough ER - Folded membrane sheets around nucleus (based on reference image)
            for (let i = 0; i < 35; i++) {
                const erGroup = new THREE.Group();
                
                // Create curved/folded membrane structure
                const erCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-0.3, -0.2, 0),
                    new THREE.Vector3(-0.1, 0.1, 0.1),
                    new THREE.Vector3(0.1, 0.2, -0.05),
                    new THREE.Vector3(0.3, -0.1, 0.1)
                ]);
                
                const erGeometry = new THREE.TubeGeometry(erCurve, 20, 0.03, 8, false);
                const erMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x6A5ACD,  // Azul-roxo baseado na imagem de refer√™ncia
                    transparent: true,
                    opacity: 0.85,
                    roughness: 0.3,
                    metalness: 0.1,
                    emissive: 0x1a1a2e,
                    emissiveIntensity: 0.2,
                    side: THREE.DoubleSide
                });
                const erTube = new THREE.Mesh(erGeometry, erMaterial);
                erGroup.add(erTube);
                
                // Add flattened membrane sheets connected to tubes
                const sheetGeometry = new THREE.PlaneGeometry(0.25, 0.15);
                const sheetMaterial = new THREE.MeshPhysicalMaterial({
                    color: 0x7B68EE,  // Cor ligeiramente mais clara para as folhas
                    transparent: true,
                    opacity: 0.75,
                    roughness: 0.4,
                    metalness: 0.05,
                    emissive: 0x16213e,
                    emissiveIntensity: 0.15,
                    side: THREE.DoubleSide
                });
                
                for (let k = 0; k < 3; k++) {
                    const sheet = new THREE.Mesh(sheetGeometry, sheetMaterial);
                    sheet.position.x = (Math.random() - 0.5) * 0.4;
                    sheet.position.y = (Math.random() - 0.5) * 0.3;
                    sheet.position.z = (Math.random() - 0.5) * 0.2;
                    sheet.rotation.x = Math.random() * Math.PI * 0.5;
                    sheet.rotation.y = Math.random() * Math.PI * 0.3;
                    erGroup.add(sheet);
                }
                
                // Ribosomes distributed on ER surface (dark dots from reference image)
                for (let j = 0; j < 18; j++) {
                    const ribosomeGeometry = new THREE.SphereGeometry(0.012, 8, 6);
                    const ribosomeMaterial = new THREE.MeshPhongMaterial({
                        color: 0x2F1B14,  // Marrom escuro baseado na imagem
                        emissive: 0x0a0a0a,
                        shininess: 30
                    });
                    const ribosome = new THREE.Mesh(ribosomeGeometry, ribosomeMaterial);
                    
                    // Position ribosomes on membrane surface
                    const ribosomeRadius = 0.035 + Math.random() * 0.01;
                    const ribosomeAngle = Math.random() * Math.PI * 2;
                    const ribosomeHeight = (Math.random() - 0.5) * 0.3;
                    
                    ribosome.position.x = Math.cos(ribosomeAngle) * ribosomeRadius;
                    ribosome.position.z = Math.sin(ribosomeAngle) * ribosomeRadius;
                    ribosome.position.y = ribosomeHeight;
                    
                    erGroup.add(ribosome);
                }
                
                // Position around nucleus in layered formation
                const radius = 1.6 + Math.random() * 0.8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                erGroup.position.x = radius * Math.sin(phi) * Math.cos(theta);
                erGroup.position.y = radius * Math.sin(phi) * Math.sin(theta);
                erGroup.position.z = radius * Math.cos(phi);
                
                // Orient towards nucleus for realistic arrangement
                erGroup.lookAt(0, 0, 0);
                erGroup.rotation.x += (Math.random() - 0.5) * 0.8;
                erGroup.rotation.y += (Math.random() - 0.5) * 0.8;
                erGroup.rotation.z += (Math.random() - 0.5) * 0.8;
                
                erNetworkGroup.add(erGroup);
            }
            
            // Smooth ER tubular network extending throughout cytoplasm
            for (let i = 0; i < 60; i++) {
                const erGroup = new THREE.Group();
                
                // Create interconnected tubular network
                const tubeGeometry = new THREE.TorusGeometry(0.12, 0.025, 6, 12);
                const tubeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00BFFF,  // Azul vibrante para o ret√≠culo liso
                    transparent: true,
                    opacity: 0.85,
                    emissive: 0x001133,
                    shininess: 100
                });
                const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
                erGroup.add(tube);
                
                // Add connecting tubes to create network
                if (Math.random() > 0.5) {
                    const connectGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6);
                    const connectMaterial = new THREE.MeshPhongMaterial({
                        color: 0x4169E1,  // Azul royal para conectores
                        transparent: true,
                        opacity: 0.8,
                        emissive: 0x001122,
                        shininess: 80
                    });
                    const connector = new THREE.Mesh(connectGeometry, connectMaterial);
                    connector.rotation.x = Math.random() * Math.PI;
                    connector.rotation.z = Math.random() * Math.PI;
                    erGroup.add(connector);
                }
                
                // Distribute throughout cytoplasm - keeping within bounds
                const radius = 2.0 + Math.random() * 2.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                erGroup.position.x = radius * Math.sin(phi) * Math.cos(theta);
                erGroup.position.y = radius * Math.sin(phi) * Math.sin(theta);
                erGroup.position.z = radius * Math.cos(phi);
                
                erGroup.rotation.x = Math.random() * Math.PI;
                erGroup.rotation.y = Math.random() * Math.PI;
                
                erNetworkGroup.add(erGroup);
            }
            
            organellesGroup.add(erNetworkGroup);
            
            // Golgi Complex (stacked cisternae)
            for (let i = 0; i < 8; i++) {
                const golgiGroup = new THREE.Group();
                
                // Stack of cisternae
                for (let j = 0; j < 6; j++) {
                    const cisternaeGeometry = new THREE.CylinderGeometry(0.25, 0.25, 0.02, 16);
                    const cisternaeMaterial = new THREE.MeshPhongMaterial({
                        color: 0xFFD700,  // Dourado vibrante para as cisternas do Golgi
                        transparent: true,
                        opacity: 0.9,
                        emissive: 0x332200,
                        shininess: 120,
                        metalness: 0.3
                    });
                    const cisternae = new THREE.Mesh(cisternaeGeometry, cisternaeMaterial);
                    cisternae.position.y = j * 0.05 - 0.125;
                    golgiGroup.add(cisternae);
                }
                
                // Vesicles around Golgi
                for (let k = 0; k < 12; k++) {
                    const vesicleGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                    const vesicleMaterial = new THREE.MeshPhongMaterial({
                        color: 0xFF8C00,  // Laranja escuro para ves√≠culas
                        emissive: 0x221100,
                        shininess: 100
                    });
                    const vesicle = new THREE.Mesh(vesicleGeometry, vesicleMaterial);
                    
                    const vesicleRadius = 0.35 + Math.random() * 0.2;
                    const vesicleAngle = (k / 12) * Math.PI * 2;
                    vesicle.position.x = Math.cos(vesicleAngle) * vesicleRadius;
                    vesicle.position.z = Math.sin(vesicleAngle) * vesicleRadius;
                    vesicle.position.y = (Math.random() - 0.5) * 0.3;
                    
                    golgiGroup.add(vesicle);
                }
                
                const radius = 2.8 + Math.random() * 1.5;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                golgiGroup.position.x = radius * Math.sin(phi) * Math.cos(theta);
                golgiGroup.position.y = radius * Math.sin(phi) * Math.sin(theta);
                golgiGroup.position.z = radius * Math.cos(phi);
                
                organellesGroup.add(golgiGroup);
            }
            
            // Lysosomes
            for (let i = 0; i < 40; i++) {
                const lysosomeGeometry = new THREE.SphereGeometry(0.08, 12, 12);
                const lysosomeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x8B008B,
                    emissive: 0x220022
                });
                const lysosome = new THREE.Mesh(lysosomeGeometry, lysosomeMaterial);
                
                const radius = 2.5 + Math.random() * 2.0;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                lysosome.position.x = radius * Math.sin(phi) * Math.cos(theta);
                lysosome.position.y = radius * Math.sin(phi) * Math.sin(theta);
                lysosome.position.z = radius * Math.cos(phi);
                
                organellesGroup.add(lysosome);
            }
            
            // Lipid droplets
            for (let i = 0; i < 25; i++) {
                const lipidGeometry = new THREE.SphereGeometry(0.12, 12, 12);
                const lipidMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.9,
                    shininess: 100
                });
                const lipid = new THREE.Mesh(lipidGeometry, lipidMaterial);
                
                const radius = 2.8 + Math.random() * 1.8;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                lipid.position.x = radius * Math.sin(phi) * Math.cos(theta);
                lipid.position.y = radius * Math.sin(phi) * Math.sin(theta);
                lipid.position.z = radius * Math.cos(phi);
                
                organellesGroup.add(lipid);
            }
            
            // Vitelo (Yolk granules) - Gr√¢nulos de vitelo distribu√≠dos no citoplasma
            // Concentra√ß√£o maior na regi√£o cortical e distribui√ß√£o heterog√™nea
            for (let i = 0; i < 120; i++) {
                const viteloGroup = new THREE.Group();
                
                // Gr√¢nulo principal de vitelo
                const viteloSize = 0.08 + Math.random() * 0.06; // Tamanho vari√°vel
                const viteloGeometry = new THREE.SphereGeometry(viteloSize, 12, 12);
                const viteloMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFA500,  // Laranja caracter√≠stico do vitelo
                    transparent: true,
                    opacity: 0.85,
                    shininess: 80,
                    emissive: 0x332200,
                    emissiveIntensity: 0.1
                });
                const viteloGranule = new THREE.Mesh(viteloGeometry, viteloMaterial);
                viteloGroup.add(viteloGranule);
                
                // Prote√≠nas e lip√≠dios internos do vitelo
                const proteinGeometry = new THREE.SphereGeometry(viteloSize * 0.6, 8, 8);
                const proteinMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFB347,
                    transparent: true,
                    opacity: 0.7
                });
                const proteinCore = new THREE.Mesh(proteinGeometry, proteinMaterial);
                viteloGroup.add(proteinCore);
                
                // Distribui√ß√£o preferencial na regi√£o cortical e intermedi√°ria
                let radius;
                if (Math.random() < 0.6) {
                    // 60% na regi√£o cortical
                    radius = 3.5 + Math.random() * 1.2;
                } else {
                    // 40% na regi√£o intermedi√°ria
                    radius = 2.5 + Math.random() * 1.0;
                }
                
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                viteloGroup.position.x = radius * Math.sin(phi) * Math.cos(theta);
                viteloGroup.position.y = radius * Math.sin(phi) * Math.sin(theta);
                viteloGroup.position.z = radius * Math.cos(phi);
                
                // Orienta√ß√£o aleat√≥ria
                viteloGroup.rotation.x = Math.random() * Math.PI;
                viteloGroup.rotation.y = Math.random() * Math.PI;
                viteloGroup.rotation.z = Math.random() * Math.PI;
                
                organellesGroup.add(viteloGroup);
            }
        }
        
        function createCorticalGranules() {
            // Cortical granules forming a distinct cortical layer just beneath plasma membrane
            const corticalGroup = new THREE.Group();
            
            // Create dense cortical layer
            for (let i = 0; i < 150; i++) {
                const granuleGroup = new THREE.Group();
                
                // Main granule body
                const geometry = new THREE.SphereGeometry(0.06, 10, 10);
                const material = new THREE.MeshPhongMaterial({
                    color: 0xFF2200,
                    shininess: 60
                });
                const granule = new THREE.Mesh(geometry, material);
                granuleGroup.add(granule);
                
                // Granule contents (enzymes)
                const contentGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const contentMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFF6347,
                    transparent: true,
                    opacity: 0.8
                });
                const content = new THREE.Mesh(contentGeometry, contentMaterial);
                granuleGroup.add(content);
                
                // Position in cortical layer (just beneath plasma membrane)
                const radius = 5.2 + Math.random() * 0.3; // Close to membrane but within cytoplasm
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                granuleGroup.position.x = radius * Math.sin(phi) * Math.cos(theta);
                granuleGroup.position.y = radius * Math.sin(phi) * Math.sin(theta);
                granuleGroup.position.z = radius * Math.cos(phi);
                
                corticalGroup.add(granuleGroup);
            }
            
            // Add cortical actin network
            for (let i = 0; i < 40; i++) {
                const points = [];
                const radius = 5.3;
                
                // Create cortical actin mesh
                for (let j = 0; j < 4; j++) {
                    const angle = (j / 4) * Math.PI * 2 + Math.random() * 0.5;
                    const x = radius * Math.cos(angle) + (Math.random() - 0.5) * 0.3;
                    const y = radius * Math.sin(angle) + (Math.random() - 0.5) * 0.3;
                    const z = (Math.random() - 0.5) * 0.4;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 16, 0.01, 4, false);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xFF69B4,
                    transparent: true,
                    opacity: 0.6
                });
                const actinMesh = new THREE.Mesh(geometry, material);
                corticalGroup.add(actinMesh);
            }
            
            corticalGroup.name = 'corticalLayer';
            organellesGroup.add(corticalGroup);
        }
        
        // Create comprehensive cytoskeleton network - radial organization
        function createCytoskeleton() {
            const cytoskeletonGroup = new THREE.Group();
            
            // Radial microtubules extending from nucleus to cortex
            for (let i = 0; i < 50; i++) {
                const points = [];
                
                // Start from nuclear envelope
                const startRadius = 1.6;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                const startX = startRadius * Math.sin(theta) * Math.cos(phi);
                const startY = startRadius * Math.sin(theta) * Math.sin(phi);
                const startZ = startRadius * Math.cos(theta);
                points.push(new THREE.Vector3(startX, startY, startZ));
                
                // Extend radially toward cortex
                const direction = new THREE.Vector3(startX, startY, startZ).normalize();
                const endRadius = 5.2 + Math.random() * 0.5;
                
                for (let j = 1; j < 8; j++) {
                    const currentRadius = startRadius + (endRadius - startRadius) * (j / 7);
                    const point = direction.clone().multiplyScalar(currentRadius);
                    
                    // Add slight curvature
                    point.add(new THREE.Vector3(
                        (Math.random() - 0.5) * 0.15,
                        (Math.random() - 0.5) * 0.15,
                        (Math.random() - 0.5) * 0.15
                    ));
                    points.push(point);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 25, 0.02, 6, false);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x00FF7F,
                    transparent: true,
                    opacity: 0.7
                });
                const microtubule = new THREE.Mesh(geometry, material);
                cytoskeletonGroup.add(microtubule);
            }
            
            // Cortical actin network (concentrated near membrane)
            for (let i = 0; i < 60; i++) {
                const points = [];
                const corticalRadius = 5.3;
                
                // Create cortical mesh pattern
                for (let j = 0; j < 5; j++) {
                    const angle = (j / 5) * Math.PI * 2 + Math.random() * 0.8;
                    const x = corticalRadius * Math.cos(angle) + (Math.random() - 0.5) * 0.4;
                    const y = corticalRadius * Math.sin(angle) + (Math.random() - 0.5) * 0.4;
                    const z = (Math.random() - 0.5) * 0.6;
                    points.push(new THREE.Vector3(x, y, z));
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 20, 0.012, 4, false);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0xFF4500,
                    transparent: true,
                    opacity: 0.8
                });
                const actinFilament = new THREE.Mesh(geometry, material);
                cytoskeletonGroup.add(actinFilament);
            }
            
            // Intermediate filaments forming supportive network
            for (let i = 0; i < 35; i++) {
                const points = [];
                
                // Start from intermediate region
                const startRadius = 2.5 + Math.random() * 1.5;
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.random() * Math.PI;
                
                const startX = startRadius * Math.sin(theta) * Math.cos(phi);
                const startY = startRadius * Math.sin(theta) * Math.sin(phi);
                const startZ = startRadius * Math.cos(theta);
                points.push(new THREE.Vector3(startX, startY, startZ));
                
                // Create curved supportive network
                for (let j = 1; j < 6; j++) {
                    const prevPoint = points[j - 1];
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 1.2,
                        (Math.random() - 0.5) * 1.2,
                        (Math.random() - 0.5) * 1.2
                    ).normalize();
                    
                    const nextPoint = prevPoint.clone().add(direction.multiplyScalar(0.8));
                    points.push(nextPoint);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 20, 0.015, 6, false);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x9370DB,
                    transparent: true,
                    opacity: 0.6
                });
                const intermediateFilament = new THREE.Mesh(geometry, material);
                cytoskeletonGroup.add(intermediateFilament);
            }
            
            // Intermediate filaments - network throughout cytoplasm
            for (let i = 0; i < 40; i++) {
                const points = [];
                
                // Random starting point in cytoplasm
                const startPoint = new THREE.Vector3(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6
                );
                points.push(startPoint);
                
                // Create curved filament
                for (let j = 1; j < 6; j++) {
                    const prevPoint = points[j - 1];
                    const direction = new THREE.Vector3(
                        (Math.random() - 0.5) * 1.5,
                        (Math.random() - 0.5) * 1.5,
                        (Math.random() - 0.5) * 1.5
                    );
                    
                    const nextPoint = prevPoint.clone().add(direction);
                    points.push(nextPoint);
                }
                
                const curve = new THREE.CatmullRomCurve3(points);
                const geometry = new THREE.TubeGeometry(curve, 25, 0.02, 6, false);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x4169E1,
                    transparent: true,
                    opacity: 0.6
                });
                const intermediateFilament = new THREE.Mesh(geometry, material);
                cytoskeletonGroup.add(intermediateFilament);
            }
            
            return cytoskeletonGroup;
         }
         
         // Create calcium release visualization
         function createCalciumRelease() {
             const calciumGroup = new THREE.Group();
             
             // Calcium ions being released from ER
             for (let i = 0; i < 150; i++) {
                 const calciumGeometry = new THREE.SphereGeometry(0.04, 8, 6);
                 const calciumMaterial = new THREE.MeshPhongMaterial({
                     color: 0x00FFFF,
                     emissive: 0x006666,
                     transparent: true,
                     opacity: 0.9
                 });
                 const calcium = new THREE.Mesh(calciumGeometry, calciumMaterial);
                 
                 // Position near ER structures
                 const angle = Math.random() * Math.PI * 2;
                 const radius = 2.5 + Math.random() * 1.5;
                 calcium.position.set(
                     Math.cos(angle) * radius,
                     (Math.random() - 0.5) * 3,
                     Math.sin(angle) * radius
                 );
                 
                 calciumGroup.add(calcium);
             }
             
             // Calcium waves moving toward membrane
             for (let i = 0; i < 50; i++) {
                 const waveGeometry = new THREE.SphereGeometry(0.06, 8, 6);
                 const waveMaterial = new THREE.MeshPhongMaterial({
                     color: 0x00CCFF,
                     emissive: 0x003366,
                     transparent: true,
                     opacity: 0.7
                 });
                 const calciumWave = new THREE.Mesh(waveGeometry, waveMaterial);
                 
                 // Position moving from ER toward membrane
                 const direction = new THREE.Vector3(
                     Math.random() - 0.5,
                     Math.random() - 0.5,
                     Math.random() - 0.5
                 ).normalize();
                 
                 const distance = 3 + Math.random() * 2;
                 calciumWave.position.copy(direction.multiplyScalar(distance));
                 
                 calciumGroup.add(calciumWave);
             }
             
             // Calcium binding to phospholipid bilayer
             for (let i = 0; i < 30; i++) {
                 const bindingGeometry = new THREE.SphereGeometry(0.05, 8, 6);
                 const bindingMaterial = new THREE.MeshPhongMaterial({
                     color: 0x0099FF,
                     emissive: 0x002244,
                     transparent: true,
                     opacity: 0.8
                 });
                 const calciumBinding = new THREE.Mesh(bindingGeometry, bindingMaterial);
                 
                 // Position on membrane surface
                 const phi = Math.random() * Math.PI;
                 const theta = Math.random() * Math.PI * 2;
                 const x = 5.8 * Math.sin(phi) * Math.cos(theta);
                 const y = 5.8 * Math.sin(phi) * Math.sin(theta);
                 const z = 5.8 * Math.cos(phi);
                 
                 calciumBinding.position.set(x, y, z);
                 calciumGroup.add(calciumBinding);
             }
             
             return calciumGroup;
          }
          
          // Create zinc release visualization and zinc sparks
          function createZincRelease() {
              const zincGroup = new THREE.Group();
              
              // Zinc sparks at membrane surface
              for (let i = 0; i < 80; i++) {
                  const sparkGeometry = new THREE.SphereGeometry(0.08, 8, 6);
                  const sparkMaterial = new THREE.MeshPhongMaterial({
                      color: 0xFFD700,
                      emissive: 0x664400,
                      transparent: true,
                      opacity: 0.9
                  });
                  const zincSpark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                  
                  // Position on membrane surface
                  const phi = Math.random() * Math.PI;
                  const theta = Math.random() * Math.PI * 2;
                  const x = 6.1 * Math.sin(phi) * Math.cos(theta);
                  const y = 6.1 * Math.sin(phi) * Math.sin(theta);
                  const z = 6.1 * Math.cos(phi);
                  
                  zincSpark.position.set(x, y, z);
                  
                  // Add glow effect
                  const glowGeometry = new THREE.SphereGeometry(0.12, 8, 6);
                  const glowMaterial = new THREE.MeshPhongMaterial({
                      color: 0xFFFF00,
                      transparent: true,
                      opacity: 0.3
                  });
                  const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                  glow.position.copy(zincSpark.position);
                  
                  zincGroup.add(zincSpark, glow);
              }
              
              // Zinc ions in cytoplasm
              for (let i = 0; i < 100; i++) {
                  const zincGeometry = new THREE.SphereGeometry(0.03, 8, 6);
                  const zincMaterial = new THREE.MeshPhongMaterial({
                      color: 0xFFA500,
                      emissive: 0x442200,
                      transparent: true,
                      opacity: 0.8
                  });
                  const zinc = new THREE.Mesh(zincGeometry, zincMaterial);
                  
                  // Random position in cytoplasm
                  const x = (Math.random() - 0.5) * 8;
                  const y = (Math.random() - 0.5) * 8;
                  const z = (Math.random() - 0.5) * 8;
                  
                  // Ensure within cell boundary
                  const distance = Math.sqrt(x*x + y*y + z*z);
                  if (distance < 5.5) {
                      zinc.position.set(x, y, z);
                      zincGroup.add(zinc);
                  }
              }
              
              // Zinc release waves
              for (let i = 0; i < 20; i++) {
                  const waveGeometry = new THREE.RingGeometry(0.5 + i * 0.2, 0.6 + i * 0.2, 16);
                  const waveMaterial = new THREE.MeshPhongMaterial({
                      color: 0xFFD700,
                      transparent: true,
                      opacity: 0.4 - i * 0.02,
                      side: THREE.DoubleSide
                  });
                  const zincWave = new THREE.Mesh(waveGeometry, waveMaterial);
                  
                  // Random orientation
                  zincWave.rotation.x = Math.random() * Math.PI;
                  zincWave.rotation.y = Math.random() * Math.PI;
                  zincWave.rotation.z = Math.random() * Math.PI;
                  
                  zincGroup.add(zincWave);
              }
              
              return zincGroup;
          }
          
          function createCD9Proteins() {
              const cd9Group = new THREE.Group();
              
              // CD9 proteins distributed on plasma membrane surface
              const cd9Geometry = new THREE.SphereGeometry(0.02, 8, 6);
              const cd9Material = new THREE.MeshPhongMaterial({ 
                  color: 0x00ff88,
                  transparent: true,
                  opacity: 0.8,
                  emissive: 0x002200
              });
              
              // Create CD9 proteins around the membrane surface
              for (let i = 0; i < 200; i++) {
                  const cd9Protein = new THREE.Mesh(cd9Geometry, cd9Material);
                  
                  // Position on membrane surface (radius ~1.0)
                  const phi = Math.random() * Math.PI * 2;
                  const theta = Math.random() * Math.PI;
                  const radius = 1.02; // Just outside membrane
                  
                  cd9Protein.position.x = radius * Math.sin(theta) * Math.cos(phi);
                  cd9Protein.position.y = radius * Math.sin(theta) * Math.sin(phi);
                  cd9Protein.position.z = radius * Math.cos(theta);
                  
                  cd9Group.add(cd9Protein);
              }
              
              return cd9Group;
          }
          
          function createZP3Proteins() {
              const zp3Group = new THREE.Group();
              
              // ZP3 proteins in zona pellucida layer
              const zp3Geometry = new THREE.SphereGeometry(0.025, 8, 6);
              const zp3Material = new THREE.MeshPhongMaterial({ 
                  color: 0xff6600,
                  transparent: true,
                  opacity: 0.7,
                  emissive: 0x331100
              });
              
              // Create ZP3 proteins in zona pellucida (radius ~1.3-1.5)
              for (let i = 0; i < 150; i++) {
                  const zp3Protein = new THREE.Mesh(zp3Geometry, zp3Material);
                  
                  const phi = Math.random() * Math.PI * 2;
                  const theta = Math.random() * Math.PI;
                  const radius = 1.3 + Math.random() * 0.2; // In zona pellucida
                  
                  zp3Protein.position.x = radius * Math.sin(theta) * Math.cos(phi);
                  zp3Protein.position.y = radius * Math.sin(theta) * Math.sin(phi);
                  zp3Protein.position.z = radius * Math.cos(theta);
                  
                  zp3Group.add(zp3Protein);
              }
              
              return zp3Group;
          }
          
          function createZincTransporters() {
              const transporterGroup = new THREE.Group();
              
              // ZIP6/ZIP10 zinc transporters on membrane
              const zipGeometry = new THREE.BoxGeometry(0.03, 0.03, 0.08);
              const zip6Material = new THREE.MeshPhongMaterial({ 
                  color: 0x9966ff,
                  transparent: true,
                  opacity: 0.8
              });
              const zip10Material = new THREE.MeshPhongMaterial({ 
                  color: 0x6699ff,
                  transparent: true,
                  opacity: 0.8
              });
              
              // Create ZIP6 transporters
              for (let i = 0; i < 80; i++) {
                  const zip6 = new THREE.Mesh(zipGeometry, zip6Material);
                  
                  const phi = Math.random() * Math.PI * 2;
                  const theta = Math.random() * Math.PI;
                  const radius = 1.0;
                  
                  zip6.position.x = radius * Math.sin(theta) * Math.cos(phi);
                  zip6.position.y = radius * Math.sin(theta) * Math.sin(phi);
                  zip6.position.z = radius * Math.cos(theta);
                  
                  // Orient transporter perpendicular to membrane
                  zip6.lookAt(new THREE.Vector3(0, 0, 0));
                  
                  transporterGroup.add(zip6);
              }
              
              // Create ZIP10 transporters
              for (let i = 0; i < 60; i++) {
                  const zip10 = new THREE.Mesh(zipGeometry, zip10Material);
                  
                  const phi = Math.random() * Math.PI * 2;
                  const theta = Math.random() * Math.PI;
                  const radius = 1.0;
                  
                  zip10.position.x = radius * Math.sin(theta) * Math.cos(phi);
                  zip10.position.y = radius * Math.sin(theta) * Math.sin(phi);
                  zip10.position.z = radius * Math.cos(theta);
                  
                  zip10.lookAt(new THREE.Vector3(0, 0, 0));
                  
                  transporterGroup.add(zip10);
              }
              
              return transporterGroup;
          }
          
          function createPLCZProteins() {
              const plczGroup = new THREE.Group();
              
              // PLCZ proteins for calcium signaling
              const plczGeometry = new THREE.SphereGeometry(0.03, 8, 6);
              const plczMaterial = new THREE.MeshPhongMaterial({ 
                  color: 0xff3366,
                  transparent: true,
                  opacity: 0.8,
                  emissive: 0x330011
              });
              
              // Create PLCZ proteins near membrane and in cytoplasm
              for (let i = 0; i < 100; i++) {
                  const plczProtein = new THREE.Mesh(plczGeometry, plczMaterial);
                  
                  // Position near membrane and in cytoplasm
                  const phi = Math.random() * Math.PI * 2;
                  const theta = Math.random() * Math.PI;
                  const radius = 0.7 + Math.random() * 0.4; // 0.7 to 1.1
                  
                  plczProtein.position.x = radius * Math.sin(theta) * Math.cos(phi);
                  plczProtein.position.y = radius * Math.sin(theta) * Math.sin(phi);
                  plczProtein.position.z = radius * Math.cos(theta);
                  
                  plczGroup.add(plczProtein);
              }
              
              return plczGroup;
          }
          
          function createSpecialStructures() {
            // Receptores ZP2 (pequenas estruturas na zona pel√∫cida)
            for (let i = 0; i < 20; i++) {
                const geometry = new THREE.ConeGeometry(0.05, 0.2, 6);
                const material = new THREE.MeshPhongMaterial({
                    color: 0x00FF00
                });
                const receptor = new THREE.Mesh(geometry, material);
                
                const radius = 6.3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                receptor.position.x = radius * Math.sin(phi) * Math.cos(theta);
                receptor.position.y = radius * Math.sin(phi) * Math.sin(theta);
                receptor.position.z = radius * Math.cos(phi);
                
                receptor.lookAt(0, 0, 0);
                
                oocyteGroup.add(receptor);
            }
            
            // Indicadores de ATP (pequenas part√≠culas brilhantes)
            for (let i = 0; i < 15; i++) {
                const geometry = new THREE.SphereGeometry(0.03, 6, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00FFFF,
                    emissive: 0x004444
                });
                const atp = new THREE.Mesh(geometry, material);
                
                const radius = 2 + Math.random() * 3;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                
                atp.position.x = radius * Math.sin(phi) * Math.cos(theta);
                atp.position.y = radius * Math.sin(phi) * Math.sin(theta);
                atp.position.z = radius * Math.cos(phi);
                
                organellesGroup.add(atp);
            }
        }
        
        function createLabels() {
            const labelData = [
                { text: "Zona Pel√∫cida", position: [6.5, 2, 2] },
                { text: "Membrana Plasm√°tica", position: [6, -1, 1] },
                { text: "N√∫cleo", position: [0, 2.5, 0] },
                { text: "Citoplasma", position: [4, 4, 0] },
                { text: "Mitoc√¥ndrias", position: [3, -3, 2] },
                { text: "Gr√¢nulos Corticais", position: [5, 0, -2] },
                { text: "Ret√≠culo Endoplasm√°tico", position: [-3, 3, 1] },
                { text: "Receptores ZP2", position: [6, 0, 3] },
                { text: "Zinc Sparks", position: [5.5, 3, -1] },
                { text: "Transportadores de Zinco", position: [6, 1, -2] },
                { text: "Espermatozoide", position: [8, 0, 0] }
            ];
            
            labelData.forEach(label => {
                const labelDiv = document.createElement('div');
                labelDiv.className = 'label';
                labelDiv.textContent = label.text;
                labelDiv.style.display = showLabels ? 'block' : 'none';
                document.body.appendChild(labelDiv);
                labels.push({ element: labelDiv, position: label.position });
            });
        }

        // ===== NOVAS FUN√á√ïES AVAN√áADAS =====

        function createZincSparks() {
            zincSparksGroup = new THREE.Group();
            zincSparksGroup.name = 'zincSparks';
            
            // Criar m√∫ltiplos pontos de zinc sparks na superf√≠cie do o√≥cito
            for (let i = 0; i < 50; i++) {
                const sparkGroup = new THREE.Group();
                
                // Part√≠cula central brilhante
                const sparkGeometry = new THREE.SphereGeometry(0.03, 8, 8);
                const sparkMaterial = new THREE.MeshPhongMaterial({
                    color: 0xFFD700,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const spark = new THREE.Mesh(sparkGeometry, sparkMaterial);
                
                // Efeito de brilho ao redor
                const glowGeometry = new THREE.SphereGeometry(0.08, 8, 8);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.3
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                
                // Posicionar na superf√≠cie do o√≥cito
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 5.9; // Pr√≥ximo √† membrana plasm√°tica
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                sparkGroup.position.set(x, y, z);
                sparkGroup.add(spark, glow);
                
                // Dados de anima√ß√£o
                sparkGroup.userData = {
                    originalIntensity: 0.8,
                    phase: Math.random() * Math.PI * 2,
                    frequency: 0.1 + Math.random() * 0.1
                };
                
                zincSparksGroup.add(sparkGroup);
            }
            
            zincSparksGroup.visible = false;
            scene.add(zincSparksGroup);
            
            // Armazenar no objeto window para evitar redeclara√ß√µes
            window.zincSparksGroup = zincSparksGroup;
        }

        function createZincTransportersAdvanced() {
            zincTransportersGroup = new THREE.Group();
            zincTransportersGroup.name = 'zincTransportersAdvanced';
            
            // ZIP (Zrt/Irt-like Protein) transporters - influxo de zinco
            for (let i = 0; i < 25; i++) {
                const zipTransporter = createZIPTransporter();
                positionOnMembrane(zipTransporter, 6.0);
                zincTransportersGroup.add(zipTransporter);
            }
            
            // ZnT (Zinc Transporter) family - efluxo de zinco
            for (let i = 0; i < 20; i++) {
                const zntTransporter = createZnTTransporter();
                positionOnMembrane(zntTransporter, 6.0);
                zincTransportersGroup.add(zntTransporter);
            }
            
            zincTransportersGroup.visible = false;
            scene.add(zincTransportersGroup);
        }

        function createZIPTransporter() {
            const zipGroup = new THREE.Group();
            zipGroup.name = 'zipTransporter';
            
            // Estrutura principal do transportador
            const mainGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.2, 8);
            const mainMaterial = new THREE.MeshPhongMaterial({
                color: 0x8A2BE2,
                transparent: true,
                opacity: 0.9
            });
            const mainBody = new THREE.Mesh(mainGeometry, mainMaterial);
            
            // Dom√≠nio de liga√ß√£o ao zinco
            const bindingSiteGeometry = new THREE.SphereGeometry(0.025, 6, 6);
            const bindingSiteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD700,
                emissive: 0x444400
            });
            const bindingSite = new THREE.Mesh(bindingSiteGeometry, bindingSiteMaterial);
            bindingSite.position.y = 0.12;
            
            // Dom√≠nios transmembrana
            for (let i = 0; i < 8; i++) {
                const tmGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.15, 4);
                const tmMaterial = new THREE.MeshPhongMaterial({
                    color: 0x9370DB,
                    transparent: true,
                    opacity: 0.7
                });
                const tmDomain = new THREE.Mesh(tmGeometry, tmMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                tmDomain.position.x = Math.cos(angle) * 0.04;
                tmDomain.position.z = Math.sin(angle) * 0.04;
                
                zipGroup.add(tmDomain);
            }
            
            zipGroup.add(mainBody, bindingSite);
            
            zipGroup.userData = {
                type: 'ZIP',
                zincBinding: false,
                transportDirection: 'influx'
            };
            
            return zipGroup;
        }

        function createZnTTransporter() {
            const zntGroup = new THREE.Group();
            zntGroup.name = 'zntTransporter';
            
            // Estrutura principal
            const mainGeometry = new THREE.CylinderGeometry(0.07, 0.09, 0.22, 8);
            const mainMaterial = new THREE.MeshPhongMaterial({
                color: 0x4B0082,
                transparent: true,
                opacity: 0.9
            });
            const mainBody = new THREE.Mesh(mainGeometry, mainMaterial);
            
            // S√≠tio de liga√ß√£o ao zinco
            const zincSiteGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const zincSiteMaterial = new THREE.MeshPhongMaterial({
                color: 0xFFD700,
                emissive: 0x333300
            });
            const zincSite = new THREE.Mesh(zincSiteGeometry, zincSiteMaterial);
            zincSite.position.y = -0.12;
            
            zntGroup.add(mainBody, zincSite);
            
            zntGroup.userData = {
                type: 'ZnT',
                zincBinding: false,
                transportDirection: 'efflux'
            };
            
            return zntGroup;
        }

        function createSpermCell() {
            spermGroup = new THREE.Group();
            spermGroup.name = 'spermCell';
            
            // Cabe√ßa do espermatozoide
            const headGeometry = new THREE.SphereGeometry(0.15, 12, 12);
            const headMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF1493,
                shininess: 100
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.scale.set(1, 1.5, 0.8); // Formato mais alongado
            
            // Acrossoma
            const acrosomeGeometry = new THREE.SphereGeometry(0.12, 10, 10);
            const acrosomeMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF69B4,
                transparent: true,
                opacity: 0.8
            });
            const acrosome = new THREE.Mesh(acrosomeGeometry, acrosomeMaterial);
            acrosome.position.y = 0.08;
            acrosome.scale.set(1, 0.6, 1);
            
            // N√∫cleo do espermatozoide
            const nucleusGeometry = new THREE.SphereGeometry(0.08, 8, 8);
            const nucleusMaterial = new THREE.MeshPhongMaterial({
                color: 0x8B008B
            });
            const nucleus = new THREE.Mesh(nucleusGeometry, nucleusMaterial);
            nucleus.position.y = -0.05;
            
            // Pe√ßa intermedi√°ria
            const midpieceGeometry = new THREE.CylinderGeometry(0.03, 0.05, 0.3, 8);
            const midpieceMaterial = new THREE.MeshPhongMaterial({
                color: 0xDC143C
            });
            const midpiece = new THREE.Mesh(midpieceGeometry, midpieceMaterial);
            midpiece.position.y = -0.35;
            
            // Mitoc√¥ndrias na pe√ßa intermedi√°ria
            for (let i = 0; i < 8; i++) {
                const mitoGeometry = new THREE.SphereGeometry(0.015, 6, 6);
                const mitoMaterial = new THREE.MeshPhongMaterial({
                    color: 0x32CD32
                });
                const mito = new THREE.Mesh(mitoGeometry, mitoMaterial);
                
                const angle = (i / 8) * Math.PI * 2;
                mito.position.x = Math.cos(angle) * 0.04;
                mito.position.y = -0.35 + (i * 0.03);
                mito.position.z = Math.sin(angle) * 0.04;
                
                spermGroup.add(mito);
            }
            
            // Flagelo
            const flagellumGeometry = new THREE.CylinderGeometry(0.01, 0.005, 2.0, 6);
            const flagellumMaterial = new THREE.MeshPhongMaterial({
                color: 0xFF6347
            });
            const flagellum = new THREE.Mesh(flagellumGeometry, flagellumMaterial);
            flagellum.position.y = -1.5;
            
            spermGroup.add(head, acrosome, nucleus, midpiece, flagellum);
            
            // Posicionar pr√≥ximo ao o√≥cito
            spermGroup.position.set(8, 0, 0);
            spermGroup.rotation.z = Math.PI / 2;
            
            spermGroup.userData = {
                acrosomeReacted: false,
                bindingToZP: false,
                penetrating: false
            };
            
            spermGroup.visible = true;
            scene.add(spermGroup);
            
            // Armazenar no objeto window para evitar redeclara√ß√µes
            window.spermGroup = spermGroup;
        }

        function createCorticalReactionSystem() {
            corticalReactionGroup = new THREE.Group();
            corticalReactionGroup.name = 'corticalReaction';
            
            // Gr√¢nulos corticais especiais para a rea√ß√£o
            for (let i = 0; i < 100; i++) {
                const granuleGroup = new THREE.Group();
                
                // Gr√¢nulo cortical
                const granuleGeometry = new THREE.SphereGeometry(0.04, 8, 8);
                const granuleMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00FFFF,
                    transparent: true,
                    opacity: 0.8
                });
                const granule = new THREE.Mesh(granuleGeometry, granuleMaterial);
                
                // Conte√∫do enzim√°tico
                const enzymeGeometry = new THREE.SphereGeometry(0.02, 6, 6);
                const enzymeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00CED1,
                    emissive: 0x003333
                });
                const enzyme = new THREE.Mesh(enzymeGeometry, enzymeMaterial);
                
                granuleGroup.add(granule, enzyme);
                
                // Posicionar na regi√£o cortical
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 5.7; // Regi√£o cortical
                
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                
                granuleGroup.position.set(x, y, z);
                
                granuleGroup.userData = {
                    released: false,
                    releaseTime: 0
                };
                
                corticalReactionGroup.add(granuleGroup);
            }
            
            corticalReactionGroup.visible = false;
            scene.add(corticalReactionGroup);
            
            // Armazenar no objeto window para evitar redeclara√ß√µes
            window.corticalReactionGroup = corticalReactionGroup;
        }

        function createCrossSectionPlane() {
            // Plano de corte invis√≠vel inicialmente
            const planeGeometry = new THREE.PlaneGeometry(15, 15);
            const planeMaterial = new THREE.MeshBasicMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            
            crossSectionPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            crossSectionPlane.position.set(0, 0, 0);
            crossSectionPlane.rotation.y = Math.PI / 2; // Corte transversal em 90 graus
            crossSectionPlane.visible = false;
            
            scene.add(crossSectionPlane);
        }

        function createQuarterSectionPlanes() {
            // Criar dois planos para cortar um quarto do o√≥cito
            // Plano 1: corte vertical (eixo Y-Z) - remove parte positiva do X
            const plane1 = new THREE.Plane(new THREE.Vector3(-1, 0, 0), 0);
            
            // Plano 2: corte horizontal (eixo X-Z) - remove parte positiva do Y
            const plane2 = new THREE.Plane(new THREE.Vector3(0, -1, 0), 0);
            
            quarterSectionPlanes = [plane1, plane2];
        }

        function createThreeQuarterSectionPlanes() {
            // Criar planos para cortar 1/4 do o√≥cito, deixando 3/4 vis√≠vel
            // Corte em cunha que remove aproximadamente 1/4 do volume
            
            // Plano 1: Corte vertical (remove parte direita) - ajustado para o tamanho do ov√≥cito
            const plane1 = new THREE.Plane(new THREE.Vector3(1, 0, 0), 2);
            
            // Plano 2: Corte diagonal (remove parte traseira-superior) - ajustado para o tamanho do ov√≥cito
            const plane2 = new THREE.Plane(new THREE.Vector3(0, 1, 1).normalize(), 1.5);
            
            threeQuarterSectionPlanes = [plane1, plane2];
        }

        // Fun√ß√£o auxiliar para posicionar objetos na membrana
        function positionOnMembrane(object, radius) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.random() * Math.PI;
            
            const x = radius * Math.sin(phi) * Math.cos(theta);
            const y = radius * Math.sin(phi) * Math.sin(theta);
            const z = radius * Math.cos(phi);
            
            object.position.set(x, y, z);
            
            // Orientar o objeto para apontar para fora da membrana
            object.lookAt(x * 1.2, y * 1.2, z * 1.2);
        }
        
        function updateLabels() {
            labels.forEach(label => {
                const vector = new THREE.Vector3(...label.position);
                vector.project(camera);
                
                const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
                const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
                
                label.element.style.left = x + 'px';
                label.element.style.top = y + 'px';
                label.element.style.display = showLabels && vector.z < 1 ? 'block' : 'none';
            });
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            
            if (isAnimating) {
                oocyteGroup.rotation.y += 0.005;
                nucleusGroup.rotation.x += 0.003;
                nucleusGroup.rotation.y += 0.002;
                organellesGroup.rotation.z += 0.001;
            }
            
            // Anima√ß√£o dos zinc sparks
            if (zincSparksGroup && zincSparksGroup.visible) {
                const time = Date.now() * 0.001;
                zincSparksGroup.children.forEach(sparkGroup => {
                    const userData = sparkGroup.userData;
                    
                    // Anima√ß√£o de pulsa√ß√£o normal
                    const intensity = userData.originalIntensity + 
                        Math.sin(time * userData.frequency + userData.phase) * 0.3;
                    
                    // Se foi ativado, intensificar o brilho
                    if (userData.triggered) {
                        const timeSinceTrigger = (Date.now() - userData.triggerTime) / 1000;
                        if (timeSinceTrigger < 2) {
                            const triggerIntensity = Math.exp(-timeSinceTrigger) * 2;
                            sparkGroup.children.forEach(child => {
                                if (child.material.emissiveIntensity !== undefined) {
                                    child.material.emissiveIntensity = intensity + triggerIntensity;
                                }
                            });
                        } else {
                            userData.triggered = false;
                        }
                    } else {
                        sparkGroup.children.forEach(child => {
                            if (child.material.emissiveIntensity !== undefined) {
                                child.material.emissiveIntensity = intensity;
                            }
                        });
                    }
                });
            }
            
            // Anima√ß√£o dos transportadores de zinco
            if (zincTransportersGroup && zincTransportersGroup.visible) {
                const time = Date.now() * 0.001;
                zincTransportersGroup.children.forEach(transporter => {
                    // Rota√ß√£o sutil para simular atividade
                    transporter.rotation.y += 0.01;
                    
                    // Pulsa√ß√£o do s√≠tio de liga√ß√£o ao zinco
                    const bindingSite = transporter.children.find(child => 
                        child.material && child.material.color.getHex() === 0xFFD700);
                    if (bindingSite) {
                        const scale = 1 + Math.sin(time * 2) * 0.1;
                        bindingSite.scale.setScalar(scale);
                    }
                });
            }
            
            // Anima√ß√£o do espermatozoide
            if (spermGroup && spermGroup.visible) {
                const time = Date.now() * 0.001;
                
                // Movimento do flagelo
                const flagellum = spermGroup.children.find(child => 
                    child.geometry && child.geometry.type === 'CylinderGeometry' && 
                    child.position.y < -1);
                if (flagellum) {
                    flagellum.rotation.x = Math.sin(time * 8) * 0.3;
                    flagellum.rotation.z = Math.cos(time * 6) * 0.2;
                }
                
                // Movimento sutil do espermatozoide
                spermGroup.position.x = 8 + Math.sin(time * 0.5) * 0.2;
                spermGroup.position.y = Math.cos(time * 0.3) * 0.1;
            }
            
            // Anima√ß√£o da rea√ß√£o cortical
            if (corticalReactionGroup && corticalReactionGroup.visible) {
                const time = Date.now();
                corticalReactionGroup.children.forEach(granuleGroup => {
                    if (granuleGroup.userData.released) {
                        const timeSinceRelease = (time - granuleGroup.userData.releaseTime) / 1000;
                        
                        if (timeSinceRelease < 3) {
                            // Expandir e desvanecer
                            const scale = 1 + timeSinceRelease * 2;
                            const opacity = Math.max(0, 1 - timeSinceRelease / 3);
                            
                            granuleGroup.scale.setScalar(scale);
                            granuleGroup.children.forEach(child => {
                                if (child.material.transparent) {
                                    child.material.opacity = opacity;
                                }
                            });
                        }
                    }
                });
            }
            
            controls.update();
            updateLabels();
            renderer.render(scene, camera);
        }
        
        function resetView() {
            camera.position.set(0, 0, 15);
            controls.reset();
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            labels.forEach(label => {
                label.element.style.display = showLabels ? 'block' : 'none';
            });
        }
        
        function toggleAnimation() {
            isAnimating = !isAnimating;
        }
        
        function toggleWireframe() {
            showWireframe = !showWireframe;
            scene.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.wireframe = showWireframe;
                }
            });
        }

        function toggleCrossSection() {
            crossSectionEnabled = !crossSectionEnabled;
            
            // Desativar corte em quarto se estiver ativo
            if (crossSectionEnabled && quarterSectionEnabled) {
                toggleQuarterSection();
            }
            
            if (crossSectionEnabled) {
                // Ativar corte transversal
                crossSectionPlane.visible = true;
                
                // Aplicar clipping plane a todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = [new THREE.Plane(new THREE.Vector3(1, 0, 0), 0)];
                                mat.clipShadows = true;
                            });
                        } else {
                            child.material.clippingPlanes = [new THREE.Plane(new THREE.Vector3(1, 0, 0), 0)];
                            child.material.clipShadows = true;
                        }
                    }
                });
                
                // Ativar clipping global
                renderer.localClippingEnabled = true;
            } else {
                // Desativar corte transversal
                crossSectionPlane.visible = false;
                
                // Remover clipping plane de todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = [];
                            });
                        } else {
                            child.material.clippingPlanes = [];
                        }
                    }
                });
                
                // Desativar clipping global
                renderer.localClippingEnabled = false;
            }
        }

        function toggleQuarterSection() {
            quarterSectionEnabled = !quarterSectionEnabled;
            
            // Desativar corte transversal se estiver ativo
            if (quarterSectionEnabled && crossSectionEnabled) {
                toggleCrossSection();
            }
            
            if (quarterSectionEnabled) {
                // Ativar corte em quarto
                // Aplicar m√∫ltiplos clipping planes a todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = quarterSectionPlanes;
                                mat.clipShadows = true;
                            });
                        } else {
                            child.material.clippingPlanes = quarterSectionPlanes;
                            child.material.clipShadows = true;
                        }
                    }
                });
                
                // Ativar clipping global
                renderer.localClippingEnabled = true;
            } else {
                // Desativar corte em quarto
                // Remover clipping planes de todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = [];
                            });
                        } else {
                            child.material.clippingPlanes = [];
                        }
                    }
                });
                
                // Desativar clipping global
                renderer.localClippingEnabled = false;
            }
        }

        function toggleThreeQuarterSection() {
            threeQuarterSectionEnabled = !threeQuarterSectionEnabled;
            
            // Desativar outros cortes se estiverem ativos
            if (threeQuarterSectionEnabled && crossSectionEnabled) {
                toggleCrossSection();
            }
            if (threeQuarterSectionEnabled && quarterSectionEnabled) {
                toggleQuarterSection();
            }
            
            if (threeQuarterSectionEnabled) {
                // Ativar corte em 3/4
                console.log('üî™ Ativando corte em 3/4 do o√≥cito...');
                console.log('üìê Planos de corte:', threeQuarterSectionPlanes);
                
                let materialsUpdated = 0;
                
                // Aplicar clipping planes a todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = threeQuarterSectionPlanes;
                                mat.clipShadows = true;
                                mat.needsUpdate = true;
                                materialsUpdated++;
                            });
                        } else {
                            child.material.clippingPlanes = threeQuarterSectionPlanes;
                            child.material.clipShadows = true;
                            child.material.needsUpdate = true;
                            materialsUpdated++;
                        }
                    }
                });
                
                console.log(`‚úÖ ${materialsUpdated} materiais atualizados com planos de corte`);
                
                // Ativar clipping global
                renderer.localClippingEnabled = true;
            } else {
                // Desativar corte em 3/4
                // Remover clipping planes de todos os objetos
                scene.traverse(child => {
                    if (child.isMesh && child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(mat => {
                                mat.clippingPlanes = [];
                            });
                        } else {
                            child.material.clippingPlanes = [];
                        }
                    }
                });
                
                // Desativar clipping global
                renderer.localClippingEnabled = false;
            }
        }

        function toggleZincSparks() {
            if (zincSparksGroup) {
                zincSparksGroup.visible = !zincSparksGroup.visible;
            }
        }

        function toggleZincTransporters() {
            if (zincTransportersGroup) {
                zincTransportersGroup.visible = !zincTransportersGroup.visible;
            }
        }

        function toggleSpermCell() {
            if (spermGroup) {
                spermGroup.visible = !spermGroup.visible;
            }
        }

        function toggleCorticalReaction() {
            if (corticalReactionGroup) {
                corticalReactionGroup.visible = !corticalReactionGroup.visible;
            }
        }

        function triggerZincSparks() {
            if (zincSparksGroup && zincSparksGroup.visible) {
                // Ativar anima√ß√£o intensa dos zinc sparks
                zincSparksGroup.children.forEach(sparkGroup => {
                    sparkGroup.userData.triggered = true;
                    sparkGroup.userData.triggerTime = Date.now();
                });
            }
        }

        function triggerCorticalReaction() {
            if (corticalReactionGroup && corticalReactionGroup.visible) {
                // Simular libera√ß√£o dos gr√¢nulos corticais
                corticalReactionGroup.children.forEach((granuleGroup, index) => {
                    setTimeout(() => {
                        granuleGroup.userData.released = true;
                        granuleGroup.userData.releaseTime = Date.now();
                    }, index * 50); // Libera√ß√£o sequencial
                });
            }
        }

        function triggerAcrosomeReaction() {
            if (spermGroup && spermGroup.visible && !spermGroup.userData.acrosomeReacted) {
                spermGroup.userData.acrosomeReacted = true;
                
                // Encontrar o acrossoma
                const acrosome = spermGroup.children.find(child => 
                    child.material && child.material.color && 
                    child.material.color.getHex() === 0xFF69B4);
                
                if (acrosome) {
                    // Anima√ß√£o de ruptura do acrossoma
                    const originalScale = acrosome.scale.clone();
                    const originalOpacity = acrosome.material.opacity;
                    
                    let progress = 0;
                    const animateAcrosome = () => {
                        progress += 0.02;
                        
                        if (progress < 1) {
                            // Expandir e desvanecer
                            const scale = 1 + progress * 2;
                            const opacity = originalOpacity * (1 - progress);
                            
                            acrosome.scale.setScalar(scale);
                            acrosome.material.opacity = opacity;
                            
                            requestAnimationFrame(animateAcrosome);
                        } else {
                            // Remover acrossoma ap√≥s rea√ß√£o
                            acrosome.visible = false;
                            
                            // Criar enzimas across√¥micas
                            createAcrosomalEnzymes();
                        }
                    };
                    
                    animateAcrosome();
                }
            }
        }

        function createAcrosomalEnzymes() {
            // Criar part√≠culas representando enzimas across√¥micas
            for (let i = 0; i < 20; i++) {
                const enzymeGeometry = new THREE.SphereGeometry(0.01, 6, 6);
                const enzymeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x00FF00,
                    transparent: true,
                    opacity: 0.8
                });
                const enzyme = new THREE.Mesh(enzymeGeometry, enzymeMaterial);
                
                // Posi√ß√£o inicial pr√≥xima √† cabe√ßa do espermatozoide
                const angle = (i / 20) * Math.PI * 2;
                enzyme.position.set(
                    spermGroup.position.x + Math.cos(angle) * 0.2,
                    spermGroup.position.y + Math.sin(angle) * 0.2,
                    spermGroup.position.z
                );
                
                // Movimento em dire√ß√£o √† zona pel√∫cida
                enzyme.userData = {
                    velocity: new THREE.Vector3(
                        -Math.cos(angle) * 0.02,
                        -Math.sin(angle) * 0.02,
                        0
                    )
                };
                
                scene.add(enzyme);
                
                // Remover ap√≥s 5 segundos
                setTimeout(() => {
                    scene.remove(enzyme);
                }, 5000);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function onMouseClick(event) {
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                const object = intersects[0].object;
                // Destacar objeto clicado
                if (object.material) {
                    const originalColor = object.material.color.clone();
                    object.material.color.setHex(0xFFFFFF);
                    setTimeout(() => {
                        object.material.color.copy(originalColor);
                    }, 500);
                }
            }
        }
        
        // Enhanced Zoom Functionality
        let currentZoom = 1.0;
        let isZooming = false;
        
        // Enhanced zoom presets with molecular visualization
        const zoomPresets = {
            overview: { distance: 25, fov: 75, description: "Vis√£o Geral", showMolecules: false, showReactions: false },
            detail: { distance: 10, fov: 60, description: "Detalhes", showMolecules: false, showReactions: false },
            ultra: { distance: 5, fov: 45, description: "Ultra Detalhes", showMolecules: true, showReactions: false },
            molecular: { distance: 2, fov: 35, description: "N√≠vel Molecular", showMolecules: true, showReactions: true },
            chemical: { distance: 1, fov: 25, description: "Rea√ß√µes Qu√≠micas", showMolecules: true, showReactions: true, showParticles: true }
        };
        
        function updateZoomDisplay() {
            const distance = camera.position.length();
            currentZoom = 25 / distance; // Normalize based on initial distance
            document.getElementById('zoom-value').textContent = currentZoom.toFixed(1) + 'x';
            document.getElementById('zoom-slider').value = currentZoom;
            
            // Update detail level based on zoom
            updateDetailLevel(currentZoom);
        }
        
        function updateDetailLevel(zoom) {
            // Show/hide elements based on zoom level
            if (organellesGroup) {
                organellesGroup.visible = zoom > 0.8;
            }
            
            // Adjust nucleus detail
            if (nucleusGroup) {
                nucleusGroup.children.forEach(child => {
                    if (child.name && child.name.includes('pore')) {
                        child.visible = zoom > 1.5;
                    }
                    if (child.name && child.name.includes('chromosome')) {
                        child.visible = zoom > 2.0;
                    }
                });
            }
            
            // Show transport proteins and pumps at higher zoom levels
            scene.traverse(child => {
                if (child.name === 'transportProteins') {
                    child.visible = zoom > 2.0;
                }
                if (child.name === 'sodiumPotassiumPumps') {
                    child.visible = zoom > 2.0;
                    // Animate pumps at molecular level
                    if (zoom > 5.0) {
                        child.children.forEach(pump => {
                            if (pump.userData.type === 'naKPump') {
                                animateNaKPump(pump);
                            }
                        });
                    }
                }
                if (child.name === 'ionChannels') {
                    child.visible = zoom > 2.5;
                }
                if (child.name === 'glucoseTransporters') {
                    child.visible = zoom > 3.0;
                }
                if (child.name === 'aminoAcidTransporters') {
                    child.visible = zoom > 3.0;
                }
            });
            
            // Show molecular interactions and chemical reactions
            if (zoom > 5.0) {
                showChemicalReactions();
                showIonMovement();
            } else {
                hideChemicalReactions();
                hideIonMovement();
            }
            
            // Show particle systems for molecular transport
            if (zoom > 8.0) {
                showMolecularTransport();
            } else {
                hideMolecularTransport();
            }
            
            // Adjust material quality based on zoom
            scene.traverse(child => {
                if (child.isMesh && child.material) {
                    if (zoom > 3.0) {
                        // High detail mode
                        if (child.material.transparent !== undefined) {
                            child.material.transparent = true;
                            child.material.opacity = Math.min(0.9, 0.6 + zoom * 0.1);
                        }
                    } else if (zoom < 1.0) {
                        // Low detail mode
                        if (child.material.transparent !== undefined) {
                            child.material.transparent = false;
                            child.material.opacity = 1.0;
                        }
                    }
                }
            });
        }
        
        function smoothZoomTo(targetDistance, duration = 1000) {
            if (isZooming) return;
            isZooming = true;
            
            const startDistance = camera.position.length();
            const startTime = Date.now();
            
            function animateZoom() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Smooth easing function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                const currentDistance = startDistance + (targetDistance - startDistance) * easeProgress;
                
                // Maintain camera direction while changing distance
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(currentDistance));
                
                updateZoomDisplay();
                
                if (progress < 1) {
                    requestAnimationFrame(animateZoom);
                } else {
                    isZooming = false;
                }
            }
            
            animateZoom();
        }
        
        function zoomIn() {
            const currentDistance = camera.position.length();
            const newDistance = Math.max(currentDistance * 0.8, 2);
            smoothZoomTo(newDistance);
        }
        
        function zoomOut() {
            const currentDistance = camera.position.length();
            const newDistance = Math.min(currentDistance * 1.25, 50);
            smoothZoomTo(newDistance);
        }
        
        function setZoomPreset(presetName) {
            const preset = zoomPresets[presetName];
            if (preset) {
                // Update camera FOV for different viewing modes
                camera.fov = preset.fov;
                camera.updateProjectionMatrix();
                
                smoothZoomTo(preset.distance, 1500);
            }
        }
        
        // Initialize zoom controls
        function initZoomControls() {
            const zoomSlider = document.getElementById('zoom-slider');
            
            zoomSlider.addEventListener('input', function(e) {
                const zoomValue = parseFloat(e.target.value);
                const targetDistance = 25 / zoomValue; // Inverse relationship
                
                // Immediate zoom for slider (no animation for responsiveness)
                const direction = camera.position.clone().normalize();
                camera.position.copy(direction.multiplyScalar(targetDistance));
                
                currentZoom = zoomValue;
                document.getElementById('zoom-value').textContent = currentZoom.toFixed(1) + 'x';
                updateDetailLevel(currentZoom);
            });
            
            // Update zoom display on mouse wheel
            controls.addEventListener('change', updateZoomDisplay);
            
            // Initial zoom display update
            updateZoomDisplay();
        }
        
        // ==================== AI ASSISTANT FUNCTIONALITY ====================
        
        // AI Knowledge Base - Comprehensive structure information
        const aiKnowledgeBase = {
            'zona_pelucida': {
                name: 'Zona Pel√∫cida',
                description: 'A zona pel√∫cida √© uma matriz extracelular glicoproteica que envolve o o√≥cito de mam√≠feros. √â uma estrutura transparente e acelular que desempenha pap√©is cruciais na fertiliza√ß√£o.',
                functions: [
                    {
                        title: 'Prote√ß√£o do O√≥cito',
                        description: 'Fornece prote√ß√£o mec√¢nica e qu√≠mica ao o√≥cito durante seu desenvolvimento e transporte atrav√©s do trato reprodutivo feminino.'
                    },
                    {
                        title: 'Reconhecimento Esperm√°tico',
                        description: 'Cont√©m receptores espec√≠ficos (ZP1, ZP2, ZP3) que permitem o reconhecimento e liga√ß√£o esp√©cie-espec√≠fica dos espermatozoides.'
                    },
                    {
                        title: 'Rea√ß√£o Across√¥mica',
                        description: 'Induz a rea√ß√£o across√¥mica nos espermatozoides, permitindo a libera√ß√£o de enzimas necess√°rias para a penetra√ß√£o.'
                    },
                    {
                        title: 'Bloqueio da Polispermia',
                        description: 'Ap√≥s a fertiliza√ß√£o, sofre altera√ß√µes estruturais que impedem a entrada de espermatozoides adicionais.'
                    }
                ],
                curiosities: 'A zona pel√∫cida √© composta principalmente por tr√™s glicoprote√≠nas (ZP1, ZP2, ZP3) e tem aproximadamente 15-20 Œºm de espessura.'
            },
            'membrana_plasmatica': {
                name: 'Membrana Plasm√°tica',
                description: 'A membrana plasm√°tica do o√≥cito √© uma bicamada lip√≠dica especializada que regula o transporte de subst√¢ncias e mant√©m a integridade celular.',
                functions: [
                    {
                        title: 'Barreira Seletiva',
                        description: 'Controla rigorosamente a entrada e sa√≠da de √≠ons, nutrientes e outras mol√©culas essenciais para o desenvolvimento.'
                    },
                    {
                        title: 'Fus√£o com Espermatozoide',
                        description: 'Local onde ocorre a fus√£o com a membrana do espermatozoide durante a fertiliza√ß√£o.'
                    },
                    {
                        title: 'Sinaliza√ß√£o Celular',
                        description: 'Cont√©m receptores e canais i√¥nicos que respondem a sinais hormonais e ambientais.'
                    },
                    {
                        title: 'Manuten√ß√£o do Potencial',
                        description: 'Mant√©m o potencial de membrana necess√°rio para processos metab√≥licos e de sinaliza√ß√£o.'
                    }
                ],
                curiosities: 'A membrana do o√≥cito possui microvilosidades que aumentam sua superf√≠cie e facilitam a intera√ß√£o com c√©lulas foliculares.'
            },
            'nucleo': {
                name: 'N√∫cleo (Ves√≠cula Germinativa)',
                description: 'O n√∫cleo do o√≥cito, tamb√©m chamado de ves√≠cula germinativa, cont√©m o material gen√©tico materno e √© o centro de controle da c√©lula.',
                functions: [
                    {
                        title: 'Armazenamento Gen√©tico',
                        description: 'Cont√©m o DNA materno organizado em cromossomos, mantendo a informa√ß√£o gen√©tica at√© a fertiliza√ß√£o.'
                    },
                    {
                        title: 'S√≠ntese de RNA',
                        description: 'Produz diversos tipos de RNA (mRNA, rRNA, tRNA) necess√°rios para a s√≠ntese proteica e desenvolvimento inicial.'
                    },
                    {
                        title: 'Regula√ß√£o da Meiose',
                        description: 'Controla a progress√£o da meiose I, permanecendo arrestado na pr√≥fase I at√© a ovula√ß√£o.'
                    },
                    {
                        title: 'Ac√∫mulo de Fatores',
                        description: 'Armazena fatores de transcri√ß√£o e prote√≠nas regulat√≥rias essenciais para o desenvolvimento embrion√°rio inicial.'
                    }
                ],
                curiosities: 'O n√∫cleo do o√≥cito pode permanecer arrestado na pr√≥fase I da meiose por d√©cadas em humanos, desde o desenvolvimento fetal at√© a ovula√ß√£o.'
            },
            'mitocondrias': {
                name: 'Mitoc√¥ndrias',
                description: 'As mitoc√¥ndrias s√£o organelas especializadas na produ√ß√£o de energia (ATP) e s√£o exclusivamente herdadas da m√£e nos mam√≠feros.',
                functions: [
                    {
                        title: 'Produ√ß√£o de ATP',
                        description: 'Geram a energia necess√°ria para todos os processos metab√≥licos do o√≥cito e desenvolvimento embrion√°rio inicial.'
                    },
                    {
                        title: 'Heran√ßa Materna',
                        description: 'Transmitem o DNA mitocondrial materno para a descend√™ncia, sendo fundamentais para a gen√©tica mitocondrial.'
                    },
                    {
                        title: 'Regula√ß√£o do C√°lcio',
                        description: 'Participam na homeostase do c√°lcio intracelular, crucial para a ativa√ß√£o do o√≥cito.'
                    },
                    {
                        title: 'Apoptose Celular',
                        description: 'Envolvidas nos mecanismos de morte celular programada quando necess√°rio.'
                    }
                ],
                curiosities: 'Um o√≥cito humano cont√©m aproximadamente 100.000-600.000 mitoc√¥ndrias, muito mais que qualquer outra c√©lula do corpo.'
            },
            'granulos_corticais': {
                name: 'Gr√¢nulos Corticais',
                description: 'Os gr√¢nulos corticais s√£o ves√≠culas secret√≥rias localizadas no c√≥rtex do o√≥cito, essenciais para prevenir a polispermia.',
                functions: [
                    {
                        title: 'Rea√ß√£o Cortical',
                        description: 'Liberam enzimas que modificam a zona pel√∫cida ap√≥s a fertiliza√ß√£o, impedindo a entrada de espermatozoides adicionais.'
                    },
                    {
                        title: 'Modifica√ß√£o da ZP',
                        description: 'Secretam proteases que clivam receptores esperm√°ticos na zona pel√∫cida, alterando sua estrutura.'
                    },
                    {
                        title: 'Eleva√ß√£o da Membrana',
                        description: 'Contribuem para a forma√ß√£o do espa√ßo perivitel√≠nico atrav√©s da libera√ß√£o de seu conte√∫do.'
                    },
                    {
                        title: 'Sinaliza√ß√£o Qu√≠mica',
                        description: 'Liberam mol√©culas sinalizadoras que coordenam eventos p√≥s-fertiliza√ß√£o.'
                    }
                ],
                curiosities: 'A exocitose dos gr√¢nulos corticais ocorre em ondas que se propagam pelo o√≥cito em poucos segundos ap√≥s a fertiliza√ß√£o.'
            },
            'reticulo_endoplasmatico': {
                name: 'Ret√≠culo Endoplasm√°tico',
                description: 'O ret√≠culo endoplasm√°tico (RE) √© uma rede de membranas internas respons√°vel pela s√≠ntese e processamento de prote√≠nas e lip√≠dios.',
                functions: [
                    {
                        title: 'S√≠ntese Proteica',
                        description: 'O RE rugoso sintetiza prote√≠nas destinadas √† secre√ß√£o e membranas celulares.'
                    },
                    {
                        title: 'S√≠ntese de Lip√≠dios',
                        description: 'O RE liso produz fosfolip√≠dios e outros lip√≠dios essenciais para membranas celulares.'
                    },
                    {
                        title: 'Armazenamento de C√°lcio',
                        description: 'Atua como principal reservat√≥rio intracelular de c√°lcio, crucial para a ativa√ß√£o do o√≥cito.'
                    },
                    {
                        title: 'Detoxifica√ß√£o',
                        description: 'Metaboliza subst√¢ncias potencialmente t√≥xicas, protegendo o o√≥cito de danos.'
                    }
                ],
                curiosities: 'O RE do o√≥cito √© extremamente desenvolvido, refletindo a intensa atividade de s√≠ntese necess√°ria para o desenvolvimento inicial.'
            },
            'complexo_golgi': {
                name: 'Complexo de Golgi',
                description: 'O complexo de Golgi √© respons√°vel pelo processamento, modifica√ß√£o e empacotamento de prote√≠nas e lip√≠dios.',
                functions: [
                    {
                        title: 'Processamento Proteico',
                        description: 'Modifica prote√≠nas atrav√©s de glicosila√ß√£o, fosforila√ß√£o e outras modifica√ß√µes p√≥s-traducionais.'
                    },
                    {
                        title: 'Forma√ß√£o de Ves√≠culas',
                        description: 'Empacota prote√≠nas e lip√≠dios em ves√≠culas para transporte intracelular.'
                    },
                    {
                        title: 'S√≠ntese de Glicoprote√≠nas',
                        description: 'Produz glicoprote√≠nas essenciais para a zona pel√∫cida e membrana plasm√°tica.'
                    },
                    {
                        title: 'Secre√ß√£o Regulada',
                        description: 'Coordena a secre√ß√£o de mol√©culas importantes para a fertiliza√ß√£o e desenvolvimento.'
                    }
                ],
                curiosities: 'Durante a matura√ß√£o do o√≥cito, o complexo de Golgi se fragmenta e se redistribui pelo citoplasma.'
            },
            'ribossomos': {
                name: 'Ribossomos',
                description: 'Os ribossomos s√£o complexos ribonucleoproteicos respons√°veis pela s√≠ntese de prote√≠nas, fundamentais para o desenvolvimento embrion√°rio.',
                functions: [
                    {
                        title: 'S√≠ntese Proteica',
                        description: 'Traduzem mRNA em prote√≠nas essenciais para o desenvolvimento e metabolismo celular.'
                    },
                    {
                        title: 'Armazenamento Materno',
                        description: 'Acumulam-se durante a oog√™nese para sustentar a s√≠ntese proteica ap√≥s a fertiliza√ß√£o.'
                    },
                    {
                        title: 'Regula√ß√£o Traducional',
                        description: 'Controlam a express√£o g√™nica ao n√≠vel da tradu√ß√£o durante o desenvolvimento inicial.'
                    },
                    {
                        title: 'Produ√ß√£o de Enzimas',
                        description: 'Sintetizam enzimas metab√≥licas cruciais para os primeiros est√°gios do desenvolvimento.'
                    }
                ],
                curiosities: 'O o√≥cito acumula milh√µes de ribossomos durante sua matura√ß√£o, preparando-se para a intensa s√≠ntese proteica p√≥s-fertiliza√ß√£o.'
            },
            'vesiculas_lipidicas': {
                name: 'Ves√≠culas Lip√≠dicas',
                description: 'Organelas especializadas no armazenamento de lip√≠dios neutros, fornecendo energia e componentes de membrana.',
                functions: [
                    {
                        title: 'Reserva Energ√©tica',
                        description: 'Armazenam triglicer√≠deos e √©steres de colesterol como fonte de energia para o desenvolvimento.'
                    },
                    {
                        title: 'S√≠ntese de Membranas',
                        description: 'Fornecem lip√≠dios para a forma√ß√£o de novas membranas durante a divis√£o celular.'
                    },
                    {
                        title: 'Metabolismo Hormonal',
                        description: 'Participam na s√≠ntese e metabolismo de horm√¥nios esteroides.'
                    },
                    {
                        title: 'Sinaliza√ß√£o Lip√≠dica',
                        description: 'Produzem mol√©culas lip√≠dicas sinalizadoras importantes para o desenvolvimento.'
                    }
                ],
                curiosities: 'As ves√≠culas lip√≠dicas podem ocupar at√© 20% do volume citoplasm√°tico em o√≥citos de algumas esp√©cies.'
            },
            'centrossomo': {
                name: 'Centrossomo',
                description: 'Centro organizador de microt√∫bulos que coordena a divis√£o celular e organiza√ß√£o do citoesqueleto.',
                functions: [
                    {
                        title: 'Organiza√ß√£o de Microt√∫bulos',
                        description: 'Nucleia e organiza a rede de microt√∫bulos do citoesqueleto celular.'
                    },
                    {
                        title: 'Forma√ß√£o do Fuso',
                        description: 'Essencial para a forma√ß√£o do fuso mei√≥tico durante a matura√ß√£o do o√≥cito.'
                    },
                    {
                        title: 'Divis√£o Celular',
                        description: 'Coordena a segrega√ß√£o cromoss√¥mica durante a meiose e mitose.'
                    },
                    {
                        title: 'Polaridade Celular',
                        description: 'Estabelece e mant√©m a polaridade celular atrav√©s da organiza√ß√£o do citoesqueleto.'
                    }
                ],
                curiosities: 'O centrossomo do o√≥cito √© herdado maternalmente e √© crucial para as primeiras divis√µes embrion√°rias.'
            },
            'peroxissomos': {
                name: 'Peroxissomos',
                description: 'Organelas especializadas em rea√ß√µes de oxida√ß√£o e metabolismo de √°cidos graxos e detoxifica√ß√£o.',
                functions: [
                    {
                        title: 'Beta-oxida√ß√£o',
                        description: 'Realizam a oxida√ß√£o de √°cidos graxos de cadeia longa, gerando energia.'
                    },
                    {
                        title: 'Detoxifica√ß√£o',
                        description: 'Neutralizam esp√©cies reativas de oxig√™nio e outras subst√¢ncias t√≥xicas.'
                    },
                    {
                        title: 'Metabolismo de Purinas',
                        description: 'Participam no catabolismo de purinas e s√≠ntese de plasmalog√™nios.'
                    },
                    {
                        title: 'Homeostase Redox',
                        description: 'Mant√™m o equil√≠brio redox celular atrav√©s de enzimas antioxidantes.'
                    }
                ],
                curiosities: 'Os peroxissomos cont√™m catalase, uma das enzimas mais eficientes conhecidas, capaz de decompor milh√µes de mol√©culas de H2O2 por segundo.'
            },
            'aparato_golgi_fragmentado': {
                name: 'Aparato de Golgi Fragmentado',
                description: 'Durante a matura√ß√£o, o Golgi se fragmenta em pequenas ves√≠culas distribu√≠das pelo citoplasma.',
                functions: [
                    {
                        title: 'Redistribui√ß√£o Funcional',
                        description: 'Permite distribui√ß√£o uniforme de enzimas de processamento pelo citoplasma.'
                    },
                    {
                        title: 'Prepara√ß√£o para Divis√£o',
                        description: 'Facilita a distribui√ß√£o equitativa de organelas durante a divis√£o celular.'
                    },
                    {
                        title: 'Processamento Distribu√≠do',
                        description: 'Mant√©m capacidade de processamento proteico em m√∫ltiplos locais celulares.'
                    },
                    {
                        title: 'Reorganiza√ß√£o P√≥s-fertiliza√ß√£o',
                        description: 'Prepara-se para r√°pida reorganiza√ß√£o ap√≥s a ativa√ß√£o do o√≥cito.'
                    }
                ],
                curiosities: 'A fragmenta√ß√£o do Golgi √© um marcador da matura√ß√£o oocit√°ria e √© revers√≠vel ap√≥s a fertiliza√ß√£o.'
             },
             'corona_radiata': {
                 name: 'Corona Radiata',
                 description: 'Camada externa de c√©lulas foliculares que circunda o o√≥cito, fornecendo suporte nutricional e prote√ß√£o.',
                 functions: [
                     {
                         title: 'Suporte Nutricional',
                         description: 'Fornece nutrientes essenciais e fatores de crescimento para o o√≥cito em desenvolvimento.'
                     },
                     {
                         title: 'Comunica√ß√£o Celular',
                         description: 'Estabelece comunica√ß√£o atrav√©s de jun√ß√µes gap com o o√≥cito.'
                     },
                     {
                         title: 'Prote√ß√£o Mec√¢nica',
                         description: 'Protege o o√≥cito de danos mec√¢nicos durante o transporte no trato reprodutivo.'
                     },
                     {
                         title: 'Regula√ß√£o da Matura√ß√£o',
                         description: 'Participa na regula√ß√£o do processo de matura√ß√£o oocit√°ria.'
                     }
                 ],
                 curiosities: 'A corona radiata √© removida pelos espermatozoides durante o processo de fertiliza√ß√£o atrav√©s de enzimas espec√≠ficas.'
             },
             'espaco_perivitelino': {
                 name: 'Espa√ßo Perivitelino',
                 description: 'Espa√ßo entre a membrana plasm√°tica do o√≥cito e a zona pel√∫cida, importante para a fertiliza√ß√£o.',
                 functions: [
                     {
                         title: 'Rea√ß√£o Cortical',
                         description: 'Local onde ocorre a libera√ß√£o do conte√∫do dos gr√¢nulos corticais ap√≥s a fertiliza√ß√£o.'
                     },
                     {
                         title: 'Preven√ß√£o de Polispermia',
                         description: 'Expande-se ap√≥s a fertiliza√ß√£o para prevenir a entrada de espermatozoides adicionais.'
                     },
                     {
                         title: 'Transporte Molecular',
                         description: 'Permite o transporte de mol√©culas entre o o√≥cito e a zona pel√∫cida.'
                     },
                     {
                         title: 'Ambiente Controlado',
                         description: 'Mant√©m um microambiente espec√≠fico ao redor do o√≥cito.'
                     }
                 ],
                 curiosities: 'O espa√ßo perivitelino se expande dramaticamente ap√≥s a fertiliza√ß√£o, criando uma barreira f√≠sica contra a polispermia.'
             },
             'citoesqueleto': {
                 name: 'Citoesqueleto',
                 description: 'Rede de filamentos proteicos que mant√©m a forma celular e organiza as organelas.',
                 functions: [
                     {
                         title: 'Suporte Estrutural',
                         description: 'Mant√©m a forma esf√©rica caracter√≠stica do o√≥cito e a integridade celular.'
                     },
                     {
                         title: 'Transporte Intracelular',
                         description: 'Facilita o movimento de organelas e ves√≠culas pelo citoplasma.'
                     },
                     {
                         title: 'Organiza√ß√£o da Meiose',
                         description: 'Essencial para a forma√ß√£o e fun√ß√£o do fuso mei√≥tico.'
                     },
                     {
                         title: 'Polariza√ß√£o Celular',
                         description: 'Estabelece e mant√©m a polaridade necess√°ria para a divis√£o assim√©trica.'
                     }
                 ],
                 curiosities: 'O citoesqueleto do o√≥cito √© altamente din√¢mico e se reorganiza drasticamente durante a matura√ß√£o e fertiliza√ß√£o.'
             },
             'granulos_de_pigmento': {
                 name: 'Gr√¢nulos de Pigmento',
                 description: 'Estruturas contendo pigmentos que podem influenciar a colora√ß√£o e prote√ß√£o do o√≥cito.',
                 functions: [
                     {
                         title: 'Prote√ß√£o UV',
                         description: 'Protegem contra danos causados por radia√ß√£o ultravioleta.'
                     },
                     {
                         title: 'Antioxida√ß√£o',
                         description: 'Cont√™m compostos antioxidantes que protegem contra estresse oxidativo.'
                     },
                     {
                         title: 'Sinaliza√ß√£o Visual',
                         description: 'Podem servir como indicadores visuais da qualidade do o√≥cito.'
                     },
                     {
                         title: 'Metabolismo Energ√©tico',
                         description: 'Alguns pigmentos participam em processos metab√≥licos espec√≠ficos.'
                     }
                 ],
                 curiosities: 'A presen√ßa e distribui√ß√£o de gr√¢nulos de pigmento podem variar entre esp√©cies e indicar a qualidade do o√≥cito.'
             },
             'complexos_de_poros_nucleares': {
                 name: 'Complexos de Poros Nucleares',
                 description: 'Estruturas especializadas na membrana nuclear que controlam o transporte n√∫cleo-citoplasma.',
                 functions: [
                     {
                         title: 'Transporte Nuclear',
                         description: 'Regulam o transporte bidirecional de mol√©culas entre n√∫cleo e citoplasma.'
                     },
                     {
                         title: 'Controle da Express√£o G√™nica',
                         description: 'Controlam a exporta√ß√£o de mRNA e importa√ß√£o de fatores de transcri√ß√£o.'
                     },
                     {
                         title: 'Sinaliza√ß√£o Celular',
                         description: 'Participam na transdu√ß√£o de sinais que afetam a express√£o g√™nica.'
                     },
                     {
                         title: 'Regula√ß√£o do Ciclo Celular',
                         description: 'Controlam o transporte de prote√≠nas reguladoras do ciclo celular.'
                     }
                 ],
                 curiosities: 'Durante a quebra do envelope nuclear na meiose, os complexos de poros se dispersam e depois se reorganizam.'
             },
             'vesiculas_endociticas': {
                 name: 'Ves√≠culas Endoc√≠ticas',
                 description: 'Ves√≠culas formadas pela internaliza√ß√£o de material da superf√≠cie celular.',
                 functions: [
                     {
                         title: 'Capta√ß√£o de Nutrientes',
                         description: 'Internalizam nutrientes e fatores de crescimento do meio extracelular.'
                     },
                     {
                         title: 'Reciclagem de Receptores',
                         description: 'Reciclam receptores de membrana ap√≥s a liga√ß√£o com ligantes.'
                     },
                     {
                         title: 'Regula√ß√£o da Superf√≠cie',
                         description: 'Controlam a composi√ß√£o e √°rea da superf√≠cie celular.'
                     },
                     {
                         title: 'Processamento de Sinais',
                         description: 'Participam no processamento de sinais extracelulares.'
                     }
                 ],
                 curiosities: 'A endocitose √© particularmente ativa durante o crescimento do o√≥cito para captar nutrientes das c√©lulas foliculares.'
             }
         };
        
        // AI Assistant State
        let aiAssistantVisible = false;
        let currentStructure = null;
        let openaiApiKey = localStorage.getItem('openai_api_key') || '';
        
        // OpenAI Integration for Advanced Structure Identification
        class OpenAIStructureIdentifier {
            constructor() {
                this.apiKey = openaiApiKey;
                this.baseURL = 'https://api.openai.com/v1/chat/completions';
            }
            
            setApiKey(key) {
                this.apiKey = key;
                openaiApiKey = key;
                localStorage.setItem('openai_api_key', key);
            }
            
            async identifyStructure(structureData) {
                if (!this.apiKey) {
                    console.log('üîë Nenhuma chave API configurada, usando fallback');
                    return this.getFallbackIdentification(structureData);
                }
                
                try {
                    console.log('ü§ñ Iniciando identifica√ß√£o com IA OpenAI...');
                    console.log('üìç Dados da estrutura:', structureData);
                    
                    const prompt = this.createIdentificationPrompt(structureData);
                    console.log('üìù Prompt gerado:', prompt.substring(0, 200) + '...');
                    
                    const response = await fetch(this.baseURL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.apiKey}`
                        },
                        body: JSON.stringify({
                            model: 'gpt-4',
                            messages: [
                                {
                                    role: 'system',
                                    content: 'Voc√™ √© um especialista em biologia celular e reprodutiva, com foco em estruturas do ov√≥cito. Forne√ßa informa√ß√µes precisas, detalhadas e cient√≠ficas sobre estruturas celulares.'
                                },
                                {
                                    role: 'user',
                                    content: prompt
                                }
                            ],
                            max_tokens: 800,
                            temperature: 0.3
                        })
                    });
                    
                    console.log('üì° Status da resposta:', response.status);
                    
                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error('‚ùå Erro da API:', response.status, errorText);
                        throw new Error(`API Error: ${response.status} - ${errorText}`);
                    }
                    
                    const data = await response.json();
                    console.log('‚úÖ Resposta da API recebida:', data);
                    
                    const result = this.parseAIResponse(data.choices[0].message.content);
                    console.log('üéØ Resultado final:', result);
                    
                    return result;
                    
                } catch (error) {
                    console.error('‚ùå Erro na identifica√ß√£o OpenAI:', error);
                    console.log('üîÑ Usando fallback...');
                    return this.getFallbackIdentification(structureData);
                }
            }
            
            createIdentificationPrompt(structureData) {
                const distanceFromCenter = Math.sqrt(
                    structureData.position.x * structureData.position.x + 
                    structureData.position.y * structureData.position.y + 
                    structureData.position.z * structureData.position.z
                );
                
                let locationContext = '';
                if (distanceFromCenter > 15) {
                    locationContext = 'IMPORTANTE: Esta posi√ß√£o est√° no MEIO EXTRACELULAR (fora do ov√≥cito). N√ÉO identifique como organelas internas.';
                } else if (distanceFromCenter < 5) {
                    locationContext = 'Esta posi√ß√£o est√° pr√≥xima ao CENTRO do ov√≥cito (regi√£o nuclear).';
                } else if (distanceFromCenter < 10) {
                    locationContext = 'Esta posi√ß√£o est√° na regi√£o CITOPLASM√ÅTICA do ov√≥cito.';
                } else {
                    locationContext = 'Esta posi√ß√£o est√° na regi√£o PERIF√âRICA do ov√≥cito (pr√≥xima √† membrana).';
                }
                
                return `
                Identifique e descreva detalhadamente a seguinte estrutura do ov√≥cito:
                
                Dados da estrutura:
                - Cor: RGB(${Math.round(structureData.color.r * 255)}, ${Math.round(structureData.color.g * 255)}, ${Math.round(structureData.color.b * 255)})
                - Posi√ß√£o: (${structureData.position.x.toFixed(2)}, ${structureData.position.y.toFixed(2)}, ${structureData.position.z.toFixed(2)})
                - Dist√¢ncia do centro: ${distanceFromCenter.toFixed(2)} unidades
                - Tamanho aproximado: ${structureData.size || 'N√£o especificado'}
                - Contexto de localiza√ß√£o: ${locationContext}
                
                REGRAS IMPORTANTES:
                - Se a dist√¢ncia do centro for > 15, identifique como "Meio Extracelular" ou estruturas externas
                - Se a dist√¢ncia for < 5, considere estruturas nucleares ou centrais
                - Se a dist√¢ncia for 5-10, considere organelas citoplasm√°ticas
                - Se a dist√¢ncia for 10-15, considere estruturas perif√©ricas ou membranares
                - NUNCA identifique meio extracelular como organelas internas
                
                Por favor, forne√ßa:
                1. Nome cient√≠fico da estrutura (baseado na localiza√ß√£o)
                2. Descri√ß√£o detalhada (2-3 frases)
                3. Principais fun√ß√µes (3-4 fun√ß√µes espec√≠ficas)
                4. Curiosidade cient√≠fica interessante
                5. Import√¢ncia para a fertiliza√ß√£o/reprodu√ß√£o
                
                Formato da resposta em JSON:
                {
                    "name": "Nome da Estrutura",
                    "description": "Descri√ß√£o detalhada...",
                    "functions": [
                        {"title": "Fun√ß√£o 1", "description": "Descri√ß√£o da fun√ß√£o 1"},
                        {"title": "Fun√ß√£o 2", "description": "Descri√ß√£o da fun√ß√£o 2"},
                        {"title": "Fun√ß√£o 3", "description": "Descri√ß√£o da fun√ß√£o 3"}
                    ],
                    "curiosity": "Curiosidade cient√≠fica...",
                    "importance": "Import√¢ncia para reprodu√ß√£o..."
                }
                `;
            }
            
            parseAIResponse(response) {
                try {
                    console.log('Raw AI Response:', response);
                    
                    // Tentar extrair JSON da resposta
                    const jsonMatch = response.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        const parsedData = JSON.parse(jsonMatch[0]);
                        console.log('Parsed AI Data:', parsedData);
                        
                        // Validar se tem os campos necess√°rios
                        if (parsedData.name && parsedData.description) {
                            return parsedData;
                        }
                    }
                    
                    // Tentar extrair informa√ß√µes manualmente do texto
                    const lines = response.split('\n').filter(line => line.trim());
                    let extractedName = 'Estrutura Identificada pela IA';
                    let extractedDescription = '';
                    
                    // Procurar por padr√µes de nome
                    for (const line of lines) {
                        if (line.toLowerCase().includes('nome') || line.toLowerCase().includes('estrutura')) {
                            const nameMatch = line.match(/:\s*(.+)/);
                            if (nameMatch) {
                                extractedName = nameMatch[1].trim();
                                break;
                            }
                        }
                    }
                    
                    // Procurar por descri√ß√£o
                    for (const line of lines) {
                        if (line.toLowerCase().includes('descri√ß√£o') || line.toLowerCase().includes('description')) {
                            const descMatch = line.match(/:\s*(.+)/);
                            if (descMatch) {
                                extractedDescription = descMatch[1].trim();
                                break;
                            }
                        }
                    }
                    
                    if (!extractedDescription) {
                        extractedDescription = response.substring(0, 200) + '...';
                    }
                    
                    return {
                        name: extractedName,
                        description: extractedDescription,
                        functions: [
                            {title: 'Fun√ß√£o Identificada', description: 'Baseado na an√°lise da IA OpenAI'}
                        ],
                        curiosity: 'Informa√ß√£o gerada pela IA OpenAI',
                        importance: 'Relevante para o funcionamento celular'
                    };
                } catch (error) {
                    console.error('Error parsing AI response:', error);
                    return this.getFallbackIdentification();
                }
            }
            
            getFallbackIdentification(structureData = null) {
                if (!structureData) {
                    return {
                        name: 'Estrutura N√£o Identificada',
                        description: 'Esta estrutura n√£o p√¥de ser identificada automaticamente. Configure sua chave da API OpenAI para obter identifica√ß√£o avan√ßada.',
                        functions: [
                            {title: 'Configura√ß√£o Necess√°ria', description: 'Adicione sua chave da API OpenAI para identifica√ß√£o autom√°tica'}
                        ],
                        curiosity: 'A IA pode identificar estruturas celulares com precis√£o quando configurada adequadamente.',
                        importance: 'Todas as estruturas do ov√≥cito s√£o importantes para a reprodu√ß√£o.'
                    };
                }
                
                // Identifica√ß√£o baseada na posi√ß√£o e cor
                const color = structureData.color;
                const position = structureData.position;
                const distanceFromCenter = Math.sqrt(position.x * position.x + position.y * position.y + position.z * position.z);
                
                // Verificar se est√° no meio extracelular (longe do centro)
                if (distanceFromCenter > 15) {
                    return {
                        name: 'Meio Extracelular',
                        description: 'Regi√£o externa ao ov√≥cito, contendo fluido folicular e outras subst√¢ncias que circundam a c√©lula.',
                        functions: [
                            {title: 'Suporte Nutricional', description: 'Fornece nutrientes e fatores de crescimento para o ov√≥cito.'},
                            {title: 'Prote√ß√£o Mec√¢nica', description: 'Oferece prote√ß√£o f√≠sica contra danos externos.'},
                            {title: 'Comunica√ß√£o Qu√≠mica', description: 'Permite a troca de sinais qu√≠micos entre c√©lulas.'},
                            {title: 'Transporte de Mol√©culas', description: 'Facilita o movimento de subst√¢ncias ao redor do ov√≥cito.'}
                        ],
                        curiosity: 'O meio extracelular cont√©m uma complexa mistura de prote√≠nas, horm√¥nios e fatores de crescimento essenciais para a matura√ß√£o do ov√≥cito.',
                        importance: 'Fundamental para manter o ambiente adequado para o desenvolvimento e matura√ß√£o do ov√≥cito.'
                    };
                }
                
                // Identifica√ß√£o b√°sica baseada na cor para estruturas internas
                if (color.r > 0.9 && color.g > 0.8 && color.b < 0.2) {
                    return aiKnowledgeBase['zona_pelucida'];
                } else if (color.r > 0.9 && color.g < 0.5 && color.b > 0.6) {
                    return aiKnowledgeBase['membrana_plasmatica'];
                } else if (color.r < 0.6 && color.g < 0.5 && color.b > 0.8) {
                    return aiKnowledgeBase['nucleo'];
                } else if (color.r < 0.4 && color.g > 0.7 && color.b < 0.4) {
                    return aiKnowledgeBase['mitocondrias'];
                } else if (color.r > 0.9 && color.g < 0.4 && color.b < 0.2) {
                    return aiKnowledgeBase['granulos_corticais'];
                } else if (color.r < 0.2 && color.g > 0.7 && color.b > 0.8) {
                    return aiKnowledgeBase['reticulo_endoplasmatico'];
                } else if (distanceFromCenter < 5) {
                    // Se est√° pr√≥ximo ao centro, provavelmente √© uma organela central
                    return aiKnowledgeBase['nucleo'];
                } else if (distanceFromCenter < 10) {
                    // Se est√° na regi√£o intermedi√°ria, pode ser citoplasma ou organelas
                    return {
                        name: 'Citoplasma',
                        description: 'Regi√£o gelatinosa que preenche o interior da c√©lula, contendo diversas organelas e mol√©culas essenciais.',
                        functions: [
                            {title: 'Suporte Estrutural', description: 'Mant√©m a forma e organiza√ß√£o interna da c√©lula.'},
                            {title: 'Transporte Intracelular', description: 'Facilita o movimento de organelas e mol√©culas.'},
                            {title: 'Metabolismo Celular', description: 'Local onde ocorrem muitas rea√ß√µes metab√≥licas.'},
                            {title: 'Armazenamento', description: 'Armazena nutrientes e mol√©culas importantes.'}
                        ],
                        curiosity: 'O citoplasma do ov√≥cito √© extremamente rico em organelas e mRNA, preparando-se para sustentar o desenvolvimento embrion√°rio inicial.',
                        importance: 'Essencial para manter todas as fun√ß√µes vitais da c√©lula e fornecer o ambiente adequado para as organelas.'
                    };
                } else {
                    // Para outras regi√µes, retornar uma identifica√ß√£o gen√©rica
                    return {
                        name: 'Estrutura Celular',
                        description: 'Componente estrutural do ov√≥cito que desempenha fun√ß√µes espec√≠ficas no desenvolvimento e matura√ß√£o celular.',
                        functions: [
                            {title: 'Fun√ß√£o Estrutural', description: 'Contribui para a organiza√ß√£o e integridade celular.'},
                            {title: 'Suporte Metab√≥lico', description: 'Participa em processos metab√≥licos celulares.'},
                            {title: 'Comunica√ß√£o Celular', description: 'Pode estar envolvida em sinaliza√ß√£o intracelular.'}
                        ],
                        curiosity: 'Cada estrutura do ov√≥cito tem um papel espec√≠fico na prepara√ß√£o para a fertiliza√ß√£o.',
                        importance: 'Contribui para o funcionamento adequado do ov√≥cito e sua capacidade reprodutiva.'
                    };
                }
            }
        }
        
        // Initialize OpenAI Structure Identifier
        const aiIdentifier = new OpenAIStructureIdentifier();
        
        // AI Assistant Functions
        function toggleAI() {
            const aiPanel = document.getElementById('ai-assistant');
            const toggleBtn = document.getElementById('ai-toggle-btn');
            
            if (aiAssistantVisible) {
                hideAI();
            } else {
                showAI();
            }
        }
        
        function showAI() {
            const aiPanel = document.getElementById('ai-assistant');
            const toggleBtn = document.getElementById('ai-toggle-btn');
            const hint = document.getElementById('ai-hint');
            
            aiPanel.classList.remove('hidden');
            toggleBtn.style.display = 'none';
            hint.style.display = 'none';
            aiAssistantVisible = true;
        }
        
        function hideAI() {
            const aiPanel = document.getElementById('ai-assistant');
            const toggleBtn = document.getElementById('ai-toggle-btn');
            const hint = document.getElementById('ai-hint');
            
            aiPanel.classList.add('hidden');
            toggleBtn.style.display = 'block';
            hint.style.display = 'block';
            aiAssistantVisible = false;
        }
        
        function updateAIContentLoading() {
            const content = document.getElementById('ai-content');
            content.innerHTML = `
                <div class="ai-structure-name">üîç Analisando Estrutura...</div>
                <div class="ai-description">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="loading-spinner"></div>
                        A IA est√° identificando a estrutura clicada. Aguarde...
                    </div>
                </div>
                <div class="ai-function">
                    <div class="ai-function-title">ü§ñ IA OpenAI</div>
                    <div>Utilizando intelig√™ncia artificial para an√°lise precisa da estrutura celular.</div>
                </div>
            `;
        }
        
        function updateAIContentWithStructure(structure) {
            const content = document.getElementById('ai-content');
            
            if (!structure) {
                content.innerHTML = `
                    <div class="ai-structure-name">Estrutura Desconhecida</div>
                    <div class="ai-description">
                        Esta estrutura n√£o foi identificada. Configure sua chave da API OpenAI para obter identifica√ß√£o avan√ßada.
                    </div>
                `;
                return;
            }
            
            let functionsHTML = '';
            if (structure.functions && Array.isArray(structure.functions)) {
                structure.functions.forEach(func => {
                    functionsHTML += `
                        <div class="ai-function">
                            <div class="ai-function-title">${func.title}</div>
                            <div>${func.description}</div>
                        </div>
                    `;
                });
            }
            
            let curiosityHTML = '';
            if (structure.curiosity || structure.curiosities) {
                curiosityHTML = `
                    <div class="ai-function">
                        <div class="ai-function-title">üî¨ Curiosidade:</div>
                        <div>${structure.curiosity || structure.curiosities}</div>
                    </div>
                `;
            }
            
            let importanceHTML = '';
            if (structure.importance) {
                importanceHTML = `
                    <div class="ai-function">
                        <div class="ai-function-title">‚ö° Import√¢ncia:</div>
                        <div>${structure.importance}</div>
                    </div>
                `;
            }
            
            content.innerHTML = `
                <div class="ai-structure-name">${structure.name}</div>
                <div class="ai-description">${structure.description}</div>
                ${functionsHTML}
                ${curiosityHTML}
                ${importanceHTML}
                <div class="ai-powered-badge">
                    <span>ü§ñ Identificado por IA OpenAI</span>
                </div>
            `;
            
            currentStructure = structure.name;
        }
        
        function updateAIContent(structureKey) {
            const content = document.getElementById('ai-content');
            const structure = aiKnowledgeBase[structureKey];
            
            if (!structure) {
                content.innerHTML = `
                    <div class="ai-structure-name">Estrutura Desconhecida</div>
                    <div class="ai-description">
                        Esta estrutura n√£o foi identificada no banco de dados. Clique em outras partes do modelo para obter informa√ß√µes detalhadas.
                    </div>
                `;
                return;
            }
            
            let functionsHTML = '';
            structure.functions.forEach(func => {
                functionsHTML += `
                    <div class="ai-function">
                        <div class="ai-function-title">${func.title}</div>
                        <div>${func.description}</div>
                    </div>
                `;
            });
            
            content.innerHTML = `
                <div class="ai-structure-name">${structure.name}</div>
                <div class="ai-description">${structure.description}</div>
                ${functionsHTML}
                <div class="ai-function">
                    <div class="ai-function-title">üî¨ Curiosidade:</div>
                    <div>${structure.curiosities}</div>
                </div>
            `;
            
            currentStructure = structureKey;
        }
        
        // Enhanced click detection with AI integration
        async function onMouseClick(event) {
            event.preventDefault();
            
            const mouse = new THREE.Vector2();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // Get all meshes in the scene
            const meshes = [];
            scene.traverse((child) => {
                if (child.isMesh) {
                    meshes.push(child);
                }
            });
            
            const intersects = raycaster.intersectObjects(meshes);
            
            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;
                const intersectionPoint = intersects[0].point;
                
                // Show AI panel immediately
                showAI();
                
                // Show loading state
                updateAIContentLoading();
                
                // Prepare structure data for AI analysis
                const structureData = {
                    color: clickedObject.material ? clickedObject.material.color : new THREE.Color(0.5, 0.5, 0.5),
                    position: intersectionPoint,
                    size: clickedObject.geometry ? clickedObject.geometry.boundingSphere?.radius : null,
                    objectName: clickedObject.name || 'unnamed',
                    materialType: clickedObject.material ? clickedObject.material.type : 'unknown'
                };
                
                // Visual feedback - highlight clicked object
                if (clickedObject.material) {
                    const originalEmissive = clickedObject.material.emissive.clone();
                    clickedObject.material.emissive.setHex(0x444444);
                    
                    setTimeout(() => {
                        clickedObject.material.emissive.copy(originalEmissive);
                    }, 500);
                }
                
                try {
                    // Use AI to identify the structure
                    const structureInfo = await aiIdentifier.identifyStructure(structureData);
                    updateAIContentWithStructure(structureInfo);
                } catch (error) {
                    console.error('Error identifying structure:', error);
                    // Fallback to basic identification
                    const fallbackInfo = aiIdentifier.getFallbackIdentification(structureData);
                    updateAIContentWithStructure(fallbackInfo);
                }
            }
        }
        
        // OpenAI Configuration Functions
        function toggleAIConfig() {
            const configPanel = document.getElementById('ai-config-panel');
            const isHidden = configPanel.classList.contains('hidden');
            
            if (isHidden) {
                configPanel.classList.remove('hidden');
                loadSavedAPIKey();
            } else {
                configPanel.classList.add('hidden');
            }
        }
        
        function loadSavedAPIKey() {
            const savedKey = localStorage.getItem('openai_api_key');
            const input = document.getElementById('openai-key-input');
            if (savedKey && input) {
                input.value = savedKey;
            }
        }
        
        function saveOpenAIKey() {
            const input = document.getElementById('openai-key-input');
            const status = document.getElementById('ai-config-status');
            const key = input.value.trim();
            
            if (!key) {
                showConfigStatus('Por favor, insira uma chave v√°lida.', 'error');
                return;
            }
            
            if (!key.startsWith('sk-')) {
                showConfigStatus('A chave deve come√ßar com "sk-"', 'error');
                return;
            }
            
            aiIdentifier.setApiKey(key);
            showConfigStatus('Chave salva com sucesso! ‚úÖ', 'success');
            
            setTimeout(() => {
                toggleAIConfig();
            }, 1500);
        }
        
        async function testOpenAIConnection() {
            const input = document.getElementById('openai-key-input');
            const key = input.value.trim();
            
            if (!key) {
                showConfigStatus('Insira uma chave para testar.', 'error');
                return;
            }
            
            showConfigStatus('Testando conex√£o... üîÑ', 'info');
            
            try {
                const testData = {
                    color: new THREE.Color(0.9, 0.8, 0.1),
                    position: new THREE.Vector3(0, 0, 0),
                    size: 1.0
                };
                
                // Temporarily set the key for testing
                const originalKey = aiIdentifier.apiKey;
                aiIdentifier.setApiKey(key);
                
                const result = await aiIdentifier.identifyStructure(testData);
                
                if (result && result.name && result.name !== 'Estrutura N√£o Identificada') {
                    showConfigStatus('Conex√£o bem-sucedida! ‚úÖ', 'success');
                } else {
                    showConfigStatus('Conex√£o OK, mas resposta inesperada.', 'info');
                }
                
            } catch (error) {
                console.error('Test error:', error);
                showConfigStatus('Erro na conex√£o. Verifique a chave. ‚ùå', 'error');
            }
        }
        
        function clearOpenAIKey() {
            const input = document.getElementById('openai-key-input');
            input.value = '';
            localStorage.removeItem('openai_api_key');
            aiIdentifier.setApiKey('');
            showConfigStatus('Chave removida.', 'info');
        }
        
        function showConfigStatus(message, type) {
            const status = document.getElementById('ai-config-status');
            status.textContent = message;
            status.className = `ai-config-status ${type}`;
            status.style.display = 'block';
            
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 3000);
            }
        }
        
        // Initialize AI Assistant
        function initAIAssistant() {
            // Load saved API key on startup
            loadSavedAPIKey();
            
            // Hide hint after 10 seconds
            setTimeout(() => {
                const hint = document.getElementById('ai-hint');
                if (hint && !aiAssistantVisible) {
                    hint.style.opacity = '0';
                    setTimeout(() => {
                        hint.style.display = 'none';
                    }, 1000);
                }
            }, 10000);
        }
        
        // Enhanced controls setup
        function enhanceControls() {
            // Improve zoom sensitivity
            controls.zoomSpeed = 1.5;
            controls.rotateSpeed = 0.8;
            controls.panSpeed = 1.2;
            
            // Better zoom limits
            controls.minDistance = 2;
            controls.maxDistance = 50;
            
            // Smoother damping
            controls.dampingFactor = 0.08;
        }
        
        // Chemical Reaction Visualization System
        let chemicalReactionGroup = null;
        let ionMovementGroup = null;
        let molecularTransportGroup = null;
        let reactionParticles = [];
        let ionParticles = [];
        let transportParticles = [];

        // Novas estruturas avan√ßadas
        
        function createChemicalReactionSystem() {
            chemicalReactionGroup = new THREE.Group();
            chemicalReactionGroup.name = 'chemicalReactions';
            chemicalReactionGroup.visible = false;
            
            // ATP synthesis visualization
            createATPSynthesis();
            
            // Ion exchange reactions
            createIonExchangeReactions();
            
            // Glucose metabolism
            createGlucoseMetabolism();
            
            scene.add(chemicalReactionGroup);
        }
        
        function createATPSynthesis() {
            const atpGroup = new THREE.Group();
            atpGroup.name = 'atpSynthesis';
            
            // ATP molecules
            for (let i = 0; i < 20; i++) {
                const atpGeometry = new THREE.SphereGeometry(0.05, 8, 6);
                const atpMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00, 
                    transparent: true, 
                    opacity: 0.8,
                    emissive: 0x002200
                });
                const atp = new THREE.Mesh(atpGeometry, atpMaterial);
                
                // Position around mitochondria
                const angle = (i / 20) * Math.PI * 2;
                atp.position.set(
                    Math.cos(angle) * 3 + (Math.random() - 0.5) * 0.5,
                    (Math.random() - 0.5) * 2,
                    Math.sin(angle) * 3 + (Math.random() - 0.5) * 0.5
                );
                
                atp.userData = { type: 'atp', phase: Math.random() * Math.PI * 2 };
                atpGroup.add(atp);
            }
            
            chemicalReactionGroup.add(atpGroup);
        }
        
        function createIonExchangeReactions() {
            const ionGroup = new THREE.Group();
            ionGroup.name = 'ionExchange';
            
            // Sodium ions (Na+)
            for (let i = 0; i < 15; i++) {
                const naGeometry = new THREE.SphereGeometry(0.03, 6, 4);
                const naMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xff6600, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const na = new THREE.Mesh(naGeometry, naMaterial);
                
                na.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                
                na.userData = { 
                    type: 'sodium', 
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02,
                        (Math.random() - 0.5) * 0.02
                    )
                };
                ionGroup.add(na);
            }
            
            // Potassium ions (K+)
            for (let i = 0; i < 12; i++) {
                const kGeometry = new THREE.SphereGeometry(0.035, 6, 4);
                const kMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x9966ff, 
                    transparent: true, 
                    opacity: 0.9 
                });
                const k = new THREE.Mesh(kGeometry, kMaterial);
                
                k.position.set(
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8,
                    (Math.random() - 0.5) * 8
                );
                
                k.userData = { 
                    type: 'potassium', 
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.015,
                        (Math.random() - 0.5) * 0.015,
                        (Math.random() - 0.5) * 0.015
                    )
                };
                ionGroup.add(k);
            }
            
            chemicalReactionGroup.add(ionGroup);
        }
        
        function createGlucoseMetabolism() {
            const glucoseGroup = new THREE.Group();
            glucoseGroup.name = 'glucoseMetabolism';
            
            // Glucose molecules
            for (let i = 0; i < 10; i++) {
                const glucoseGeometry = new THREE.OctahedronGeometry(0.06, 1);
                const glucoseMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffff00, 
                    transparent: true, 
                    opacity: 0.8,
                    emissive: 0x222200
                });
                const glucose = new THREE.Mesh(glucoseGeometry, glucoseMaterial);
                
                glucose.position.set(
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6,
                    (Math.random() - 0.5) * 6
                );
                
                glucose.userData = { 
                    type: 'glucose', 
                    rotationSpeed: (Math.random() + 0.5) * 0.02 
                };
                glucoseGroup.add(glucose);
            }
            
            chemicalReactionGroup.add(glucoseGroup);
        }
        
        function showChemicalReactions() {
            if (!chemicalReactionGroup) {
                createChemicalReactionSystem();
            }
            chemicalReactionGroup.visible = true;
            animateChemicalReactions();
        }
        
        function hideChemicalReactions() {
            if (chemicalReactionGroup) {
                chemicalReactionGroup.visible = false;
            }
        }
        
        function animateChemicalReactions() {
            if (!chemicalReactionGroup || !chemicalReactionGroup.visible) return;
            
            const time = Date.now() * 0.001;
            
            chemicalReactionGroup.traverse(child => {
                if (child.isMesh && child.userData) {
                    switch (child.userData.type) {
                        case 'atp':
                            child.position.y += Math.sin(time * 2 + child.userData.phase) * 0.001;
                            child.material.emissive.setHex(
                                Math.sin(time * 3 + child.userData.phase) > 0 ? 0x004400 : 0x002200
                            );
                            break;
                        case 'sodium':
                        case 'potassium':
                            child.position.add(child.userData.velocity);
                            // Bounce off boundaries
                            if (Math.abs(child.position.x) > 4) child.userData.velocity.x *= -1;
                            if (Math.abs(child.position.y) > 4) child.userData.velocity.y *= -1;
                            if (Math.abs(child.position.z) > 4) child.userData.velocity.z *= -1;
                            break;
                        case 'glucose':
                            child.rotation.x += child.userData.rotationSpeed;
                            child.rotation.y += child.userData.rotationSpeed * 0.7;
                            break;
                    }
                }
            });
            
            requestAnimationFrame(animateChemicalReactions);
        }
        
        function showIonMovement() {
            // Ion movement is part of chemical reactions
            showChemicalReactions();
        }
        
        function hideIonMovement() {
            // Ion movement is part of chemical reactions
            hideChemicalReactions();
        }
        
        function showMolecularTransport() {
            if (!molecularTransportGroup) {
                createMolecularTransportSystem();
            }
            molecularTransportGroup.visible = true;
            animateMolecularTransport();
        }
        
        function hideMolecularTransport() {
            if (molecularTransportGroup) {
                molecularTransportGroup.visible = false;
            }
        }
        
        function createMolecularTransportSystem() {
            molecularTransportGroup = new THREE.Group();
            molecularTransportGroup.name = 'molecularTransport';
            molecularTransportGroup.visible = false;
            
            // Create transport pathways
            createTransportPathways();
            
            // Create molecular cargo
            createMolecularCargo();
            
            scene.add(molecularTransportGroup);
        }
        
        function createTransportPathways() {
            const pathwayMaterial = new THREE.LineBasicMaterial({ 
                color: 0x00ffff, 
                transparent: true, 
                opacity: 0.3 
            });
            
            // Create curved pathways through membrane
            for (let i = 0; i < 8; i++) {
                const curve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(-5, 0, 0),
                    new THREE.Vector3(-2.5, Math.sin(i) * 0.5, Math.cos(i) * 0.5),
                    new THREE.Vector3(0, Math.sin(i * 2) * 0.3, Math.cos(i * 2) * 0.3),
                    new THREE.Vector3(2.5, Math.sin(i * 3) * 0.5, Math.cos(i * 3) * 0.5),
                    new THREE.Vector3(5, 0, 0)
                ]);
                
                const points = curve.getPoints(50);
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const pathway = new THREE.Line(geometry, pathwayMaterial);
                
                pathway.rotation.y = (i / 8) * Math.PI * 2;
                molecularTransportGroup.add(pathway);
            }
        }
        
        function createMolecularCargo() {
            // Create various molecular cargo types
            const cargoTypes = [
                { color: 0xff0080, size: 0.04, name: 'protein' },
                { color: 0x80ff00, size: 0.03, name: 'lipid' },
                { color: 0x0080ff, size: 0.025, name: 'ion' },
                { color: 0xff8000, size: 0.035, name: 'metabolite' }
            ];
            
            cargoTypes.forEach((type, typeIndex) => {
                for (let i = 0; i < 5; i++) {
                    const geometry = new THREE.SphereGeometry(type.size, 8, 6);
                    const material = new THREE.MeshPhongMaterial({ 
                        color: type.color, 
                        transparent: true, 
                        opacity: 0.8,
                        emissive: type.color,
                        emissiveIntensity: 0.1
                    });
                    const cargo = new THREE.Mesh(geometry, material);
                    
                    cargo.userData = {
                        type: type.name,
                        pathIndex: (typeIndex * 2 + i) % 8,
                        progress: Math.random(),
                        speed: 0.005 + Math.random() * 0.005
                    };
                    
                    molecularTransportGroup.add(cargo);
                }
            });
        }
        
        function animateMolecularTransport() {
            if (!molecularTransportGroup || !molecularTransportGroup.visible) return;
            
            molecularTransportGroup.children.forEach(child => {
                if (child.isMesh && child.userData) {
                    const pathIndex = child.userData.pathIndex;
                    child.userData.progress += child.userData.speed;
                    
                    if (child.userData.progress > 1) {
                        child.userData.progress = 0;
                    }
                    
                    // Calculate position along transport pathway
                    const angle = (pathIndex / 8) * Math.PI * 2;
                    const radius = 4.5;
                    const x = Math.cos(angle) * radius * (1 - child.userData.progress * 2);
                    const y = Math.sin(child.userData.progress * Math.PI * 2) * 0.5;
                    const z = Math.sin(angle) * radius * (1 - child.userData.progress * 2);
                    
                    child.position.set(x, y, z);
                    
                    // Add some rotation
                    child.rotation.x += 0.02;
                    child.rotation.y += 0.015;
                }
            });
            
            requestAnimationFrame(animateMolecularTransport);
        }
        
        function animateNaKPump(pump) {
            if (!pump.userData.animating) {
                pump.userData.animating = true;
                pump.userData.originalScale = pump.scale.clone();
                
                const animate = () => {
                    if (pump.userData.animating) {
                        const time = Date.now() * 0.003;
                        const scale = 1 + Math.sin(time) * 0.1;
                        pump.scale.setScalar(scale);
                        
                        // Change color to indicate activity
                        if (pump.material) {
                            const intensity = (Math.sin(time * 2) + 1) * 0.5;
                            pump.material.emissiveIntensity = intensity * 0.3;
                        }
                        
                        requestAnimationFrame(animate);
                    }
                };
                animate();
            }
        }
        
        // Transport Control Functions
         function toggleTransportProteins() {
             const checkbox = document.getElementById('toggle-transport-proteins');
             scene.traverse(child => {
                 if (child.name === 'transportProteins') {
                     child.visible = checkbox.checked;
                 }
             });
         }
         
         function toggleNaKPumps() {
             const checkbox = document.getElementById('toggle-na-k-pumps');
             scene.traverse(child => {
                 if (child.name === 'sodiumPotassiumPumps') {
                     child.visible = checkbox.checked;
                     if (checkbox.checked) {
                         // Start pump animations
                         child.children.forEach(pump => {
                             if (pump.userData.type === 'naKPump') {
                                 animateNaKPump(pump);
                             }
                         });
                     } else {
                         // Stop pump animations
                         child.children.forEach(pump => {
                             if (pump.userData.animating) {
                                 pump.userData.animating = false;
                                 if (pump.userData.originalScale) {
                                     pump.scale.copy(pump.userData.originalScale);
                                 }
                             }
                         });
                     }
                 }
             });
         }
         
         function toggleIonChannels() {
             const checkbox = document.getElementById('toggle-ion-channels');
             scene.traverse(child => {
                 if (child.name === 'ionChannels') {
                     child.visible = checkbox.checked;
                 }
             });
         }
         
         function toggleGlucoseTransporters() {
             const checkbox = document.getElementById('toggle-glucose-transporters');
             scene.traverse(child => {
                 if (child.name === 'glucoseTransporters') {
                     child.visible = checkbox.checked;
                 }
             });
         }
         
         function toggleChemicalReactionsControl() {
             const checkbox = document.getElementById('toggle-chemical-reactions');
             if (checkbox.checked) {
                 showChemicalReactions();
             } else {
                 hideChemicalReactions();
             }
         }
         
         function toggleMolecularTransportControl() {
             const checkbox = document.getElementById('toggle-molecular-transport');
             if (checkbox.checked) {
                 showMolecularTransport();
             } else {
                 hideMolecularTransport();
             }
         }
         
         // Initialize enhanced zoom when page loads
        window.addEventListener('load', function() {
            setTimeout(() => {
                initZoomControls();
                enhanceControls();
                createChemicalReactionSystem();
                createMolecularTransportSystem();
            }, 100);
        });

         // AI Metabolism System Integration
         let aiEngine, metabolismSimulator, proteinSimulator, controlInterface, dynamicVisualization;

         function initializeAIMetabolismSystem() {
             try {
                 console.log('üîÑ Iniciando sistema de IA metab√≥lica...');
                 
                 // Verifica√ß√£o final de depend√™ncias
                 if (typeof ProteinTransportSimulator === 'undefined') {
                     throw new Error('ProteinTransportSimulator n√£o est√° definido');
                 }
                 if (typeof MetabolismSimulator === 'undefined') {
                     throw new Error('MetabolismSimulator n√£o est√° definido');
                 }
                 if (typeof AIMetabolismEngine === 'undefined') {
                     throw new Error('AIMetabolismEngine n√£o est√° definido');
                 }
                 if (typeof MetabolismControlInterface === 'undefined') {
                     throw new Error('MetabolismControlInterface n√£o est√° definido');
                 }
                 if (typeof DynamicVisualization === 'undefined') {
                     throw new Error('DynamicVisualization n√£o est√° definido');
                 }
                 
                 // Validate that scene exists
                 if (!scene) {
                     throw new Error('Scene n√£o est√° inicializada. Aguarde a carga completa da p√°gina.');
                 }
                 
                 console.log('‚úÖ Todas as depend√™ncias verificadas com sucesso');
                 
                 // Initialize AI Engine with offline mode
                 console.log('üß† Inicializando AI Engine...');
                 aiEngine = new AIMetabolismEngine();
                 aiEngine.offlineMode = true; // Ativar modo offline
                 console.log('‚úÖ AI Engine inicializado');
                 
                 // Initialize Metabolism Simulator
                 console.log('üî¨ Inicializando Metabolism Simulator...');
                 metabolismSimulator = new MetabolismSimulator(scene, aiEngine);
                 console.log('‚úÖ Metabolism Simulator inicializado');
                 
                 // Initialize Protein Transport Simulator
                 console.log('üöö Inicializando Protein Transport Simulator...');
                 proteinSimulator = new ProteinTransportSimulator(scene, aiEngine);
                 console.log('‚úÖ Protein Transport Simulator inicializado');
                 
                 // Initialize Control Interface
                 console.log('üéõÔ∏è Inicializando Control Interface...');
                 controlInterface = new MetabolismControlInterface(
                     aiEngine, 
                     metabolismSimulator, 
                     proteinSimulator
                 );
                 console.log('‚úÖ Control Interface inicializado');
                 
                 // Initialize Dynamic Visualization
                 console.log('üé® Inicializando Dynamic Visualization...');
                 dynamicVisualization = new DynamicVisualization(
                     scene, 
                     aiEngine, 
                     metabolismSimulator, 
                     proteinSimulator
                 );
                 console.log('‚úÖ Dynamic Visualization inicializado');
                 
                 console.log('üß¨ Sistema de IA Metab√≥lica inicializado com sucesso!');
                 
                 // Start automatic simulation
                 setTimeout(() => {
                     metabolismSimulator.startSimulation();
                     console.log('‚ö° Simula√ß√£o metab√≥lica iniciada automaticamente');
                 }, 2000);
                 
             } catch (error) {
                 console.error('‚ùå Erro ao inicializar sistema de IA:', error);
                 console.error('üìã Stack trace:', error.stack);
                 
                 // Log status of dependencies
                 console.log('üìä Status das depend√™ncias:');
                 console.log('- AIMetabolismEngine:', typeof AIMetabolismEngine !== 'undefined' ? '‚úÖ' : '‚ùå');
                 console.log('- MetabolismSimulator:', typeof MetabolismSimulator !== 'undefined' ? '‚úÖ' : '‚ùå');
                 console.log('- ProteinTransportSimulator:', typeof ProteinTransportSimulator !== 'undefined' ? '‚úÖ' : '‚ùå');
                 console.log('- MetabolismControlInterface:', typeof MetabolismControlInterface !== 'undefined' ? '‚úÖ' : '‚ùå');
                 console.log('- DynamicVisualization:', typeof DynamicVisualization !== 'undefined' ? '‚úÖ' : '‚ùå');
                 console.log('- Scene:', scene ? '‚úÖ' : '‚ùå');
                 
                 // Show user-friendly error message
                 const errorDiv = document.createElement('div');
                 errorDiv.style.cssText = `
                     position: fixed;
                     top: 20px;
                     left: 20px;
                     background: rgba(255, 0, 0, 0.9);
                     color: white;
                     padding: 15px;
                     border-radius: 10px;
                     z-index: 2000;
                     font-family: Arial, sans-serif;
                     max-width: 400px;
                 `;
                 errorDiv.innerHTML = `
                     <h3>‚ö†Ô∏è Sistema de IA Indispon√≠vel</h3>
                     <p>Os arquivos de IA n√£o foram carregados. Para usar a simula√ß√£o metab√≥lica:</p>
                     <ol>
                         <li>Certifique-se de que todos os arquivos JS est√£o no mesmo diret√≥rio</li>
                         <li>Recarregue a p√°gina</li>
                         <li>Verifique o console para mais detalhes</li>
                     </ol>
                     <button onclick="this.parentElement.remove()" 
                             style="background: white; color: red; border: none; padding: 5px 10px; 
                                    border-radius: 5px; cursor: pointer; margin-top: 10px;">
                         Fechar
                     </button>
                 `;
                 document.body.appendChild(errorDiv);
             }
         }

         // Global functions for external control
         window.triggerMetabolicEvent = function(eventType, intensity = 1.0) {
             if (dynamicVisualization) {
                 dynamicVisualization.triggerMetabolicEvent(eventType, intensity);
             }
         };

         window.getMetabolicReport = function() {
             if (metabolismSimulator) {
                 return metabolismSimulator.getMetabolicReport();
             }
             return null;
         };

         window.setMetabolicParameter = function(parameter, value) {
             if (aiEngine) {
                 aiEngine.metabolicState[parameter] = value;
                 console.log(`üî¨ Par√¢metro ${parameter} definido para ${value}`);
             }
         };
    </script>

    <!-- Load AI Metabolism System Scripts -->
    <script src="ai_metabolism_config.js"></script>
    <script src="metabolism_simulator.js"></script>
    <script src="protein_transport_simulator.js"></script>
    <script src="metabolism_control_interface.js"></script>
    <script src="dynamic_visualization.js"></script>

    <!-- AI System Status Indicator -->
    <div id="ai-system-status" style="
        position: fixed;
        bottom: 20px;
        left: 20px;
        background: rgba(0, 0, 0, 0.8);
        color: #00ff88;
        padding: 10px 15px;
        border-radius: 20px;
        font-family: 'Courier New', monospace;
        font-size: 12px;
        z-index: 1000;
        border: 1px solid #00ff88;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
    ">
        üß¨ Sistema de IA: Carregando...
    </div>

    <script>
        // Fun√ß√µes para controlar pain√©is retr√°teis
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const content = document.getElementById(panelId + '-content');
            const toggleBtn = document.getElementById(panelId + '-toggle');
            
            if (!panel || !content || !toggleBtn) return;
            
            const isMinimized = panel.classList.contains('panel-minimized');
            
            if (isMinimized) {
                // Expandir painel
                panel.classList.remove('panel-minimized');
                content.style.display = 'block';
                toggleBtn.textContent = '‚àí';
                
                // Anima√ß√£o de expans√£o
                setTimeout(() => {
                    content.style.opacity = '1';
                    content.style.maxHeight = 'none';
                }, 10);
            } else {
                // Minimizar painel
                content.style.opacity = '0';
                content.style.maxHeight = '0';
                toggleBtn.textContent = '+';
                
                // Aguardar anima√ß√£o antes de ocultar
                setTimeout(() => {
                    content.style.display = 'none';
                    panel.classList.add('panel-minimized');
                }, 300);
            }
        }

        // Fun√ß√£o para minimizar/maximizar painel da IA
        function toggleAIPanel() {
            const aiAssistant = document.getElementById('ai-assistant');
            const aiContent = document.querySelector('.ai-content');
            const aiConfigPanel = document.getElementById('ai-config-panel');
            
            if (!aiAssistant || !aiContent) return;
            
            const isMinimized = aiAssistant.classList.contains('ai-minimized');
            
            if (isMinimized) {
                // Expandir
                aiAssistant.classList.remove('ai-minimized');
                aiContent.style.display = 'block';
                if (!aiConfigPanel.classList.contains('hidden')) {
                    aiConfigPanel.style.display = 'block';
                }
            } else {
                // Minimizar
                aiAssistant.classList.add('ai-minimized');
                aiContent.style.display = 'none';
                aiConfigPanel.style.display = 'none';
            }
        }

        // Update AI system status
        setTimeout(() => {
            const statusDiv = document.getElementById('ai-system-status');
            if (window.AIMetabolismEngine && window.MetabolismSimulator) {
                statusDiv.innerHTML = 'üß¨ Sistema de IA: ‚úÖ Ativo';
                statusDiv.style.color = '#00ff88';
            } else {
                statusDiv.innerHTML = 'üß¨ Sistema de IA: ‚ùå Indispon√≠vel';
                statusDiv.style.color = '#ff4444';
            }
        }, 3000);

        // Hide status after 10 seconds
        setTimeout(() => {
            const statusDiv = document.getElementById('ai-system-status');
            if (statusDiv) {
                statusDiv.style.opacity = '0';
                statusDiv.style.transition = 'opacity 2s';
                setTimeout(() => statusDiv.remove(), 2000);
            }
        }, 10000);
    </script>

    <!-- Service Worker para funcionamento offline -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./service-worker.js')
                    .then(registration => {
                        console.log('‚úÖ SW registrado:', registration);
                    })
                    .catch(error => {
                        console.log('‚ö†Ô∏è SW n√£o dispon√≠vel:', error);
                    });
            });
        }
    </script>
</body>
</html>